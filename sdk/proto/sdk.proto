syntax = "proto3";

// These are funkily named "sdkProto" because protobuf is dumb and can have
// symbol collisions if all proto packages are named similarly.
option go_package = "github.com/clintjedwards/gofer/sdkProto";

package sdkProto;

service Trigger {
  // TODO(clintjedwards): We should probably make this into an actual
  //  blocking endpoint with good primitives (see consul endpoints that works
  //  similarly)

  // Check blocks until the trigger has a pipeline that should be run, then it
  // returns.
  rpc Check(CheckRequest) returns (CheckResponse);

  // Info returns information on the specific plugin
  rpc Info(InfoRequest) returns (InfoResponse);

  // Subscribe allows a trigger to keep track of all pipelines currently
  // dependant on that trigger so that we can trigger them at appropriate times.
  rpc Subscribe(SubscribeRequest) returns (SubscribeResponse);

  // Unsubscribe allows pipelines to remove their trigger subscriptions. This is
  // useful if the pipeline no longer needs to be notified about a specific
  // trigger automation.
  rpc Unsubscribe(UnsubscribeRequest) returns (UnsubscribeResponse);

  // Shutdown tells the trigger to cleanup and gracefully shutdown. If a trigger
  // does not shutdown in a time defined by the gofer API the trigger will
  // instead be Force shutdown(SIGKILL). This is to say that all triggers should
  // lean toward quick cleanups and shutdowns.
  rpc Shutdown(ShutdownRequest) returns (ShutdownResponse);

  // ExternalEvent are json blobs of gofer's /events endpoint. Normally
  // webhooks.
  rpc ExternalEvent(ExternalEventRequest) returns (ExternalEventResponse);
}

message CheckRequest {}
message CheckResponse {
  // The trigger can choose to give extra details about the
  // specific trigger event result.
  string details = 1;

  // Unique id of trigger instance.
  string pipeline_trigger_label = 2;

  // Unique identifier for pipeline.
  string pipeline_id = 3;

  // Unique identifier for namespace.
  string namespace_id = 4;

  enum Result {
    UNKNOWN = 0;
    SUCCESS = 1;
    FAILURE = 2;
    SKIPPED = 3;
  }
  Result result = 5;

  // Metadata is passed to the tasks as extra environment variables.
  map<string, string> metadata = 6;
}

message InfoRequest {}
message InfoResponse {
  // kind corresponds a unique trigger identifier, this is passed as a envvar
  // via the main process(and as such can be left empty), as the main process
  // container the configuration for which trigger "kind" corresponds to which
  // trigger container.
  string kind = 1;

  // Triggers are allowed to provide a link to more extensive documentation on
  // how to use and configure them.
  string documentation = 2;

  // A listing of all registred pipelines in the format: <namespace>/<pipeline>
  repeated string registered = 3;
}

message SubscribeRequest {
  // pipeline specific subscription id
  string pipeline_trigger_label = 1;
  string namespace_id = 2; // unique identifier for associated namespace
  string pipeline_id = 3;  // unique identifier for associated pipeline

  // pipelines are allowed to pass a configuration to triggers denoting what
  // specific settings they might like for a specific trigger. The acceptable
  // values of this config map is defined by the triggers and should be
  // mentioned in documentation.
  //
  // Additionally, the trigger should verify config settings and pass back an
  // error when it does not meet requirements.
  map<string, string> config = 4;
}
message SubscribeResponse {}

message UnsubscribeRequest {
  // pipeline specific subscription id
  string pipeline_trigger_label = 1;
  string namespace_id = 2; // unique identifier for associated namespace
  string pipeline_id = 3;  // unique identifier for associated pipeline
}
message UnsubscribeResponse {}

message ShutdownRequest {}
message ShutdownResponse {}

message ExternalEventRequest { bytes payload = 1; }
message ExternalEventResponse {}
