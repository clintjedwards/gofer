// Package sdk provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package sdk

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// CreateBootstrapTokenResponseBody defines model for CreateBootstrapTokenResponseBody.
type CreateBootstrapTokenResponseBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// Secret The secret value for the created token
	Secret string `json:"secret"`
	Token  Token  `json:"token"`
}

// CreateTokenRequestBody defines model for CreateTokenRequestBody.
type CreateTokenRequestBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// Expires The amount of time the token is valid for. Uses golang time duration strings: https://pkg.go.dev/time#ParseDuration
	Expires string `json:"expires"`

	// Metadata Various other bits of data you can attach to tokens
	Metadata map[string]string `json:"metadata"`

	// Namespaces The namespaces this token applies to; will be unauthorized at all other namespaces. This field can contain simple regexs
	Namespaces []string `json:"namespaces"`

	// TokenType The type of token to be created. Can be "management" or "client"
	TokenType string `json:"token_type"`
}

// CreateTokenResponseBody defines model for CreateTokenResponseBody.
type CreateTokenResponseBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// Secret The secret value for the created token
	Secret string `json:"secret"`
	Token  Token  `json:"token"`
}

// DeleteTokenRequestBody defines model for DeleteTokenRequestBody.
type DeleteTokenRequestBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// TokenId The unique identifier for the token you want to target
	TokenId string `json:"token_id"`
}

// DescribeSystemInfoResponseBody defines model for DescribeSystemInfoResponseBody.
type DescribeSystemInfoResponseBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// Commit The commit of the current build
	Commit string `json:"commit"`

	// Semver The semver version of the current build
	Semver string `json:"semver"`
}

// DescribeSystemSummaryResponseBody defines model for DescribeSystemSummaryResponseBody.
type DescribeSystemSummaryResponseBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// Namespaces List of all namespaces
	Namespaces []string `json:"namespaces"`

	// PipelineCount The number of pipelines registered
	PipelineCount int64 `json:"pipeline_count"`

	// RunCount The number of runs completed
	RunCount int64 `json:"run_count"`

	// TaskExecutionCount The number of task executions completed
	TaskExecutionCount int64 `json:"task_execution_count"`
}

// DescribeTokenByHashRequestBody defines model for DescribeTokenByHashRequestBody.
type DescribeTokenByHashRequestBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// TokenHash The hash of the token you want to look up.
	TokenHash string `json:"token_hash"`
}

// DescribeTokenByHashResponseBody defines model for DescribeTokenByHashResponseBody.
type DescribeTokenByHashResponseBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema        *string `json:"$schema,omitempty"`
	TokenMetadata Token   `json:"token_metadata"`
}

// DescribeTokenByIDRequestBody defines model for DescribeTokenByIDRequestBody.
type DescribeTokenByIDRequestBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// TokenId The id of the token you want to look up.
	TokenId string `json:"token_id"`
}

// DescribeTokenByIDResponseBody defines model for DescribeTokenByIDResponseBody.
type DescribeTokenByIDResponseBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema        *string `json:"$schema,omitempty"`
	TokenMetadata Token   `json:"token_metadata"`
}

// DisableTokenRequestBody defines model for DisableTokenRequestBody.
type DisableTokenRequestBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// TokenId The unique identifier for the token you want to target
	TokenId string `json:"token_id"`
}

// EnableTokenRequestBody defines model for EnableTokenRequestBody.
type EnableTokenRequestBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// TokenId The unique identifier for the token you want to target
	TokenId string `json:"token_id"`
}

// ErrorDetail defines model for ErrorDetail.
type ErrorDetail struct {
	// Location Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'
	Location *string `json:"location,omitempty"`

	// Message Error message text
	Message *string `json:"message,omitempty"`

	// Value The value at the given location
	Value *interface{} `json:"value,omitempty"`
}

// ErrorModel defines model for ErrorModel.
type ErrorModel struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Errors Optional list of individual error details
	Errors *[]ErrorDetail `json:"errors,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	Instance *string `json:"instance,omitempty"`

	// Status HTTP status code
	Status *int64 `json:"status,omitempty"`

	// Title A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
	Title *string `json:"title,omitempty"`

	// Type A URI reference to human-readable documentation for the error.
	Type *string `json:"type,omitempty"`
}

// ListTokensResponseBody defines model for ListTokensResponseBody.
type ListTokensResponseBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// Tokens A list of tokens within this namespace
	Tokens []Token `json:"tokens"`
}

// RepairOrphanRequestBody defines model for RepairOrphanRequestBody.
type RepairOrphanRequestBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// NamespaceId Unique identifier of the namespace you're targeting
	NamespaceId *string `json:"namespace_id,omitempty"`

	// PipelineId Unique identifier for the pipeline you're targeting
	PipelineId string `json:"pipeline_id"`

	// RunId Run you'd like to recover
	RunId int64 `json:"run_id"`
}

// ToggleEventIngressResponseBody defines model for ToggleEventIngressResponseBody.
type ToggleEventIngressResponseBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// Value The current value for the boolean that controls event ingress
	Value bool `json:"value"`
}

// Token defines model for Token.
type Token struct {
	// Created Time in epoch milliseconds since token was created.
	Created int64 `json:"created"`

	// Disabled If the token is inactive or not; disabled tokens cannot be used.
	Disabled bool `json:"disabled"`

	// Expires Time in epoch milliseconds when the token would expire.
	Expires int64 `json:"expires"`

	// Id The unique identifier for the token
	Id string `json:"id"`

	// Metadata Extra information about this token in label form.
	Metadata map[string]string `json:"metadata"`

	// Namespaces List of namespaces this token has access to, strings in this list can be a regex.
	Namespaces []string `json:"namespaces"`

	// TokenType The type of the token. Management tokens are essentially root.
	TokenType string `json:"token_type"`
}

// RepairOrphanParams defines parameters for RepairOrphan.
type RepairOrphanParams struct {
	Authorization string `json:"Authorization"`
}

// ToggleEventIngressParams defines parameters for ToggleEventIngress.
type ToggleEventIngressParams struct {
	Authorization string `json:"Authorization"`
}

// ListTokensParams defines parameters for ListTokens.
type ListTokensParams struct {
	Namespace     *string `form:"namespace,omitempty" json:"namespace,omitempty"`
	Authorization string  `json:"Authorization"`
}

// CreateTokenParams defines parameters for CreateToken.
type CreateTokenParams struct {
	Authorization string `json:"Authorization"`
}

// DescribeTokenByHashParams defines parameters for DescribeTokenByHash.
type DescribeTokenByHashParams struct {
	Authorization string `json:"Authorization"`
}

// DescribeTokenByIDParams defines parameters for DescribeTokenByID.
type DescribeTokenByIDParams struct {
	Authorization string `json:"Authorization"`
}

// DeleteTokenParams defines parameters for DeleteToken.
type DeleteTokenParams struct {
	Authorization string `json:"Authorization"`
}

// DisableTokenParams defines parameters for DisableToken.
type DisableTokenParams struct {
	Authorization string `json:"Authorization"`
}

// EnableTokenParams defines parameters for EnableToken.
type EnableTokenParams struct {
	Authorization string `json:"Authorization"`
}

// RepairOrphanJSONRequestBody defines body for RepairOrphan for application/json ContentType.
type RepairOrphanJSONRequestBody = RepairOrphanRequestBody

// CreateTokenJSONRequestBody defines body for CreateToken for application/json ContentType.
type CreateTokenJSONRequestBody = CreateTokenRequestBody

// DescribeTokenByHashJSONRequestBody defines body for DescribeTokenByHash for application/json ContentType.
type DescribeTokenByHashJSONRequestBody = DescribeTokenByHashRequestBody

// DescribeTokenByIDJSONRequestBody defines body for DescribeTokenByID for application/json ContentType.
type DescribeTokenByIDJSONRequestBody = DescribeTokenByIDRequestBody

// DeleteTokenJSONRequestBody defines body for DeleteToken for application/json ContentType.
type DeleteTokenJSONRequestBody = DeleteTokenRequestBody

// DisableTokenJSONRequestBody defines body for DisableToken for application/json ContentType.
type DisableTokenJSONRequestBody = DisableTokenRequestBody

// EnableTokenJSONRequestBody defines body for EnableToken for application/json ContentType.
type EnableTokenJSONRequestBody = EnableTokenRequestBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DescribeSystemInfo request
	DescribeSystemInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RepairOrphanWithBody request with any body
	RepairOrphanWithBody(ctx context.Context, params *RepairOrphanParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RepairOrphan(ctx context.Context, params *RepairOrphanParams, body RepairOrphanJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeSystemSummary request
	DescribeSystemSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToggleEventIngress request
	ToggleEventIngress(ctx context.Context, params *ToggleEventIngressParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTokens request
	ListTokens(ctx context.Context, params *ListTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenWithBody request with any body
	CreateTokenWithBody(ctx context.Context, params *CreateTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateToken(ctx context.Context, params *CreateTokenParams, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBootstrapToken request
	CreateBootstrapToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeTokenByHashWithBody request with any body
	DescribeTokenByHashWithBody(ctx context.Context, params *DescribeTokenByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DescribeTokenByHash(ctx context.Context, params *DescribeTokenByHashParams, body DescribeTokenByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeTokenByIDWithBody request with any body
	DescribeTokenByIDWithBody(ctx context.Context, params *DescribeTokenByIDParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DescribeTokenByID(ctx context.Context, params *DescribeTokenByIDParams, body DescribeTokenByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTokenWithBody request with any body
	DeleteTokenWithBody(ctx context.Context, params *DeleteTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteToken(ctx context.Context, params *DeleteTokenParams, body DeleteTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableTokenWithBody request with any body
	DisableTokenWithBody(ctx context.Context, params *DisableTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DisableToken(ctx context.Context, params *DisableTokenParams, body DisableTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableTokenWithBody request with any body
	EnableTokenWithBody(ctx context.Context, params *EnableTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnableToken(ctx context.Context, params *EnableTokenParams, body EnableTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DescribeSystemInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeSystemInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepairOrphanWithBody(ctx context.Context, params *RepairOrphanParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepairOrphanRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepairOrphan(ctx context.Context, params *RepairOrphanParams, body RepairOrphanJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepairOrphanRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeSystemSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeSystemSummaryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToggleEventIngress(ctx context.Context, params *ToggleEventIngressParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToggleEventIngressRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTokens(ctx context.Context, params *ListTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, params *CreateTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateToken(ctx context.Context, params *CreateTokenParams, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBootstrapToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBootstrapTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeTokenByHashWithBody(ctx context.Context, params *DescribeTokenByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeTokenByHashRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeTokenByHash(ctx context.Context, params *DescribeTokenByHashParams, body DescribeTokenByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeTokenByHashRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeTokenByIDWithBody(ctx context.Context, params *DescribeTokenByIDParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeTokenByIDRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeTokenByID(ctx context.Context, params *DescribeTokenByIDParams, body DescribeTokenByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeTokenByIDRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTokenWithBody(ctx context.Context, params *DeleteTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, params *DeleteTokenParams, body DeleteTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableTokenWithBody(ctx context.Context, params *DisableTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableToken(ctx context.Context, params *DisableTokenParams, body DisableTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableTokenRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableTokenWithBody(ctx context.Context, params *EnableTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableToken(ctx context.Context, params *EnableTokenParams, body EnableTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableTokenRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDescribeSystemInfoRequest generates requests for DescribeSystemInfo
func NewDescribeSystemInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/system/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRepairOrphanRequest calls the generic RepairOrphan builder with application/json body
func NewRepairOrphanRequest(server string, params *RepairOrphanParams, body RepairOrphanJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRepairOrphanRequestWithBody(server, params, "application/json", bodyReader)
}

// NewRepairOrphanRequestWithBody generates requests for RepairOrphan with any type of body
func NewRepairOrphanRequestWithBody(server string, params *RepairOrphanParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/system/repair-orphan")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewDescribeSystemSummaryRequest generates requests for DescribeSystemSummary
func NewDescribeSystemSummaryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/system/summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToggleEventIngressRequest generates requests for ToggleEventIngress
func NewToggleEventIngressRequest(server string, params *ToggleEventIngressParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/system/toggle-event-ingress")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewListTokensRequest generates requests for ListTokens
func NewListTokensRequest(server string, params *ListTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Namespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "namespace", runtime.ParamLocationQuery, *params.Namespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewCreateTokenRequest calls the generic CreateToken builder with application/json body
func NewCreateTokenRequest(server string, params *CreateTokenParams, body CreateTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, params *CreateTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewCreateBootstrapTokenRequest generates requests for CreateBootstrapToken
func NewCreateBootstrapTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/tokens/bootstrap")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeTokenByHashRequest calls the generic DescribeTokenByHash builder with application/json body
func NewDescribeTokenByHashRequest(server string, params *DescribeTokenByHashParams, body DescribeTokenByHashJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDescribeTokenByHashRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDescribeTokenByHashRequestWithBody generates requests for DescribeTokenByHash with any type of body
func NewDescribeTokenByHashRequestWithBody(server string, params *DescribeTokenByHashParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/tokens/by-hash")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewDescribeTokenByIDRequest calls the generic DescribeTokenByID builder with application/json body
func NewDescribeTokenByIDRequest(server string, params *DescribeTokenByIDParams, body DescribeTokenByIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDescribeTokenByIDRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDescribeTokenByIDRequestWithBody generates requests for DescribeTokenByID with any type of body
func NewDescribeTokenByIDRequestWithBody(server string, params *DescribeTokenByIDParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/tokens/by-id")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewDeleteTokenRequest calls the generic DeleteToken builder with application/json body
func NewDeleteTokenRequest(server string, params *DeleteTokenParams, body DeleteTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTokenRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDeleteTokenRequestWithBody generates requests for DeleteToken with any type of body
func NewDeleteTokenRequestWithBody(server string, params *DeleteTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/tokens/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewDisableTokenRequest calls the generic DisableToken builder with application/json body
func NewDisableTokenRequest(server string, params *DisableTokenParams, body DisableTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDisableTokenRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDisableTokenRequestWithBody generates requests for DisableToken with any type of body
func NewDisableTokenRequestWithBody(server string, params *DisableTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/tokens/disable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewEnableTokenRequest calls the generic EnableToken builder with application/json body
func NewEnableTokenRequest(server string, params *EnableTokenParams, body EnableTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnableTokenRequestWithBody(server, params, "application/json", bodyReader)
}

// NewEnableTokenRequestWithBody generates requests for EnableToken with any type of body
func NewEnableTokenRequestWithBody(server string, params *EnableTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/tokens/enable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DescribeSystemInfoWithResponse request
	DescribeSystemInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DescribeSystemInfoResponse, error)

	// RepairOrphanWithBodyWithResponse request with any body
	RepairOrphanWithBodyWithResponse(ctx context.Context, params *RepairOrphanParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepairOrphanResponse, error)

	RepairOrphanWithResponse(ctx context.Context, params *RepairOrphanParams, body RepairOrphanJSONRequestBody, reqEditors ...RequestEditorFn) (*RepairOrphanResponse, error)

	// DescribeSystemSummaryWithResponse request
	DescribeSystemSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DescribeSystemSummaryResponse, error)

	// ToggleEventIngressWithResponse request
	ToggleEventIngressWithResponse(ctx context.Context, params *ToggleEventIngressParams, reqEditors ...RequestEditorFn) (*ToggleEventIngressResponse, error)

	// ListTokensWithResponse request
	ListTokensWithResponse(ctx context.Context, params *ListTokensParams, reqEditors ...RequestEditorFn) (*ListTokensResponse, error)

	// CreateTokenWithBodyWithResponse request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, params *CreateTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithResponse(ctx context.Context, params *CreateTokenParams, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// CreateBootstrapTokenWithResponse request
	CreateBootstrapTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateBootstrapTokenResponse, error)

	// DescribeTokenByHashWithBodyWithResponse request with any body
	DescribeTokenByHashWithBodyWithResponse(ctx context.Context, params *DescribeTokenByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DescribeTokenByHashResponse, error)

	DescribeTokenByHashWithResponse(ctx context.Context, params *DescribeTokenByHashParams, body DescribeTokenByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*DescribeTokenByHashResponse, error)

	// DescribeTokenByIDWithBodyWithResponse request with any body
	DescribeTokenByIDWithBodyWithResponse(ctx context.Context, params *DescribeTokenByIDParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DescribeTokenByIDResponse, error)

	DescribeTokenByIDWithResponse(ctx context.Context, params *DescribeTokenByIDParams, body DescribeTokenByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*DescribeTokenByIDResponse, error)

	// DeleteTokenWithBodyWithResponse request with any body
	DeleteTokenWithBodyWithResponse(ctx context.Context, params *DeleteTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	DeleteTokenWithResponse(ctx context.Context, params *DeleteTokenParams, body DeleteTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// DisableTokenWithBodyWithResponse request with any body
	DisableTokenWithBodyWithResponse(ctx context.Context, params *DisableTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableTokenResponse, error)

	DisableTokenWithResponse(ctx context.Context, params *DisableTokenParams, body DisableTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableTokenResponse, error)

	// EnableTokenWithBodyWithResponse request with any body
	EnableTokenWithBodyWithResponse(ctx context.Context, params *EnableTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableTokenResponse, error)

	EnableTokenWithResponse(ctx context.Context, params *EnableTokenParams, body EnableTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableTokenResponse, error)
}

type DescribeSystemInfoResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *DescribeSystemInfoResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r DescribeSystemInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeSystemInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepairOrphanResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r RepairOrphanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepairOrphanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeSystemSummaryResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *DescribeSystemSummaryResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r DescribeSystemSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeSystemSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToggleEventIngressResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *ToggleEventIngressResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r ToggleEventIngressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToggleEventIngressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTokensResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *ListTokensResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r ListTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *CreateTokenResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBootstrapTokenResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *CreateBootstrapTokenResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r CreateBootstrapTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBootstrapTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeTokenByHashResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *DescribeTokenByHashResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r DescribeTokenByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeTokenByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeTokenByIDResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *DescribeTokenByIDResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r DescribeTokenByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeTokenByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableTokenResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r DisableTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableTokenResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r EnableTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DescribeSystemInfoWithResponse request returning *DescribeSystemInfoResponse
func (c *ClientWithResponses) DescribeSystemInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DescribeSystemInfoResponse, error) {
	rsp, err := c.DescribeSystemInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeSystemInfoResponse(rsp)
}

// RepairOrphanWithBodyWithResponse request with arbitrary body returning *RepairOrphanResponse
func (c *ClientWithResponses) RepairOrphanWithBodyWithResponse(ctx context.Context, params *RepairOrphanParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepairOrphanResponse, error) {
	rsp, err := c.RepairOrphanWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepairOrphanResponse(rsp)
}

func (c *ClientWithResponses) RepairOrphanWithResponse(ctx context.Context, params *RepairOrphanParams, body RepairOrphanJSONRequestBody, reqEditors ...RequestEditorFn) (*RepairOrphanResponse, error) {
	rsp, err := c.RepairOrphan(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepairOrphanResponse(rsp)
}

// DescribeSystemSummaryWithResponse request returning *DescribeSystemSummaryResponse
func (c *ClientWithResponses) DescribeSystemSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DescribeSystemSummaryResponse, error) {
	rsp, err := c.DescribeSystemSummary(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeSystemSummaryResponse(rsp)
}

// ToggleEventIngressWithResponse request returning *ToggleEventIngressResponse
func (c *ClientWithResponses) ToggleEventIngressWithResponse(ctx context.Context, params *ToggleEventIngressParams, reqEditors ...RequestEditorFn) (*ToggleEventIngressResponse, error) {
	rsp, err := c.ToggleEventIngress(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToggleEventIngressResponse(rsp)
}

// ListTokensWithResponse request returning *ListTokensResponse
func (c *ClientWithResponses) ListTokensWithResponse(ctx context.Context, params *ListTokensParams, reqEditors ...RequestEditorFn) (*ListTokensResponse, error) {
	rsp, err := c.ListTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTokensResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, params *CreateTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, params *CreateTokenParams, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// CreateBootstrapTokenWithResponse request returning *CreateBootstrapTokenResponse
func (c *ClientWithResponses) CreateBootstrapTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateBootstrapTokenResponse, error) {
	rsp, err := c.CreateBootstrapToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBootstrapTokenResponse(rsp)
}

// DescribeTokenByHashWithBodyWithResponse request with arbitrary body returning *DescribeTokenByHashResponse
func (c *ClientWithResponses) DescribeTokenByHashWithBodyWithResponse(ctx context.Context, params *DescribeTokenByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DescribeTokenByHashResponse, error) {
	rsp, err := c.DescribeTokenByHashWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeTokenByHashResponse(rsp)
}

func (c *ClientWithResponses) DescribeTokenByHashWithResponse(ctx context.Context, params *DescribeTokenByHashParams, body DescribeTokenByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*DescribeTokenByHashResponse, error) {
	rsp, err := c.DescribeTokenByHash(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeTokenByHashResponse(rsp)
}

// DescribeTokenByIDWithBodyWithResponse request with arbitrary body returning *DescribeTokenByIDResponse
func (c *ClientWithResponses) DescribeTokenByIDWithBodyWithResponse(ctx context.Context, params *DescribeTokenByIDParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DescribeTokenByIDResponse, error) {
	rsp, err := c.DescribeTokenByIDWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeTokenByIDResponse(rsp)
}

func (c *ClientWithResponses) DescribeTokenByIDWithResponse(ctx context.Context, params *DescribeTokenByIDParams, body DescribeTokenByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*DescribeTokenByIDResponse, error) {
	rsp, err := c.DescribeTokenByID(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeTokenByIDResponse(rsp)
}

// DeleteTokenWithBodyWithResponse request with arbitrary body returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithBodyWithResponse(ctx context.Context, params *DeleteTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, params *DeleteTokenParams, body DeleteTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// DisableTokenWithBodyWithResponse request with arbitrary body returning *DisableTokenResponse
func (c *ClientWithResponses) DisableTokenWithBodyWithResponse(ctx context.Context, params *DisableTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableTokenResponse, error) {
	rsp, err := c.DisableTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableTokenResponse(rsp)
}

func (c *ClientWithResponses) DisableTokenWithResponse(ctx context.Context, params *DisableTokenParams, body DisableTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableTokenResponse, error) {
	rsp, err := c.DisableToken(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableTokenResponse(rsp)
}

// EnableTokenWithBodyWithResponse request with arbitrary body returning *EnableTokenResponse
func (c *ClientWithResponses) EnableTokenWithBodyWithResponse(ctx context.Context, params *EnableTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableTokenResponse, error) {
	rsp, err := c.EnableTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableTokenResponse(rsp)
}

func (c *ClientWithResponses) EnableTokenWithResponse(ctx context.Context, params *EnableTokenParams, body EnableTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableTokenResponse, error) {
	rsp, err := c.EnableToken(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableTokenResponse(rsp)
}

// ParseDescribeSystemInfoResponse parses an HTTP response from a DescribeSystemInfoWithResponse call
func ParseDescribeSystemInfoResponse(rsp *http.Response) (*DescribeSystemInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DescribeSystemInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DescribeSystemInfoResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRepairOrphanResponse parses an HTTP response from a RepairOrphanWithResponse call
func ParseRepairOrphanResponse(rsp *http.Response) (*RepairOrphanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepairOrphanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeSystemSummaryResponse parses an HTTP response from a DescribeSystemSummaryWithResponse call
func ParseDescribeSystemSummaryResponse(rsp *http.Response) (*DescribeSystemSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DescribeSystemSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DescribeSystemSummaryResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseToggleEventIngressResponse parses an HTTP response from a ToggleEventIngressWithResponse call
func ParseToggleEventIngressResponse(rsp *http.Response) (*ToggleEventIngressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToggleEventIngressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ToggleEventIngressResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListTokensResponse parses an HTTP response from a ListTokensWithResponse call
func ParseListTokensResponse(rsp *http.Response) (*ListTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTokensResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateTokenResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBootstrapTokenResponse parses an HTTP response from a CreateBootstrapTokenWithResponse call
func ParseCreateBootstrapTokenResponse(rsp *http.Response) (*CreateBootstrapTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBootstrapTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateBootstrapTokenResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeTokenByHashResponse parses an HTTP response from a DescribeTokenByHashWithResponse call
func ParseDescribeTokenByHashResponse(rsp *http.Response) (*DescribeTokenByHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DescribeTokenByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DescribeTokenByHashResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeTokenByIDResponse parses an HTTP response from a DescribeTokenByIDWithResponse call
func ParseDescribeTokenByIDResponse(rsp *http.Response) (*DescribeTokenByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DescribeTokenByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DescribeTokenByIDResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDisableTokenResponse parses an HTTP response from a DisableTokenWithResponse call
func ParseDisableTokenResponse(rsp *http.Response) (*DisableTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseEnableTokenResponse parses an HTTP response from a EnableTokenWithResponse call
func ParseEnableTokenResponse(rsp *http.Response) (*EnableTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}
