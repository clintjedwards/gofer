// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: gofer.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// GoferClient is the client API for Gofer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GoferClient interface {
	// ListNamespaces returns all registered namespaces.
	ListNamespaces(ctx context.Context, in *ListNamespacesRequest, opts ...grpc.CallOption) (*ListNamespacesResponse, error)
	// CreateNamespace creates a new namespace that separates pipelines.
	CreateNamespace(ctx context.Context, in *CreateNamespaceRequest, opts ...grpc.CallOption) (*CreateNamespaceResponse, error)
	// GetNamespace returns a single namespace by id.
	GetNamespace(ctx context.Context, in *GetNamespaceRequest, opts ...grpc.CallOption) (*GetNamespaceResponse, error)
	// UpdateNamespace updates the details of a particular namespace by id.
	UpdateNamespace(ctx context.Context, in *UpdateNamespaceRequest, opts ...grpc.CallOption) (*UpdateNamespaceResponse, error)
	// DeleteNamespace removes a namespace by id.
	DeleteNamespace(ctx context.Context, in *DeleteNamespaceRequest, opts ...grpc.CallOption) (*DeleteNamespaceResponse, error)
	// GetPipeline returns a single pipeline by ID.
	GetPipeline(ctx context.Context, in *GetPipelineRequest, opts ...grpc.CallOption) (*GetPipelineResponse, error)
	// ListPipelines returns all registered pipelines. Can control pagination by
	// offset && limit request parameters.
	// By default ListPipelines will return the first 100 pipelines ordered by
	// creation.
	ListPipelines(ctx context.Context, in *ListPipelinesRequest, opts ...grpc.CallOption) (*ListPipelinesResponse, error)
	// EnablePipeline allows a pipeline to execute runs by allowing it to receive
	// trigger events. See DisablePipeline to prevent a pipeline from executing
	// any more runs.
	EnablePipeline(ctx context.Context, in *EnablePipelineRequest, opts ...grpc.CallOption) (*EnablePipelineResponse, error)
	// DisablePipeline prevents the pipeline from executing runs. Any trigger
	// events that would normally cause the pipeline to be run are instead
	// discarded.
	DisablePipeline(ctx context.Context, in *DisablePipelineRequest, opts ...grpc.CallOption) (*DisablePipelineResponse, error)
	// CreatePipelineRaw creates a new pipeline from a raw byte string
	// representation of a pipeline config file. This is useful if you're
	// attempting to create the pipeline from a source that is not held in source
	// control or maybe not publicly available.
	CreatePipelineRaw(ctx context.Context, in *CreatePipelineRawRequest, opts ...grpc.CallOption) (*CreatePipelineRawResponse, error)
	// CreatePipelineByURL creates a new pipeline from a pipeline config stored
	// remotely. Many forms of a remote URL can be used here. You can view a full
	// list of accepted protocols and extra options here:
	// https://github.com/hashicorp/go-getter#general-all-protocols
	CreatePipelineByURL(ctx context.Context, in *CreatePipelineByURLRequest, opts ...grpc.CallOption) (*CreatePipelineByURLResponse, error)
	// UpdatePipelineRaw updates a pipeline by raw byte string representation of a
	// pipeline config file. Updating a pipeline requires the pipeline to adhere
	// to two states:
	//    1) The pipeline must not have any current runs in progress.
	//    2) The pipeline must be in a disabled state.
	UpdatePipelineRaw(ctx context.Context, in *UpdatePipelineRawRequest, opts ...grpc.CallOption) (*UpdatePipelineRawResponse, error)
	// UpdatePipelineByURL updates a pipeline from a pipeline config stored
	// remotely. Many forms of a remote URL can be used. You can view a full list
	// of accepted protocols and extra options here:
	// https://github.com/hashicorp/go-getter#general-all-protocols
	//
	// In order to update the pipeline, it must adhere to two states:
	//    1) The pipeline must not have any current runs in progress.
	//    2) The pipeline must be in a disabled state.
	UpdatePipelineByURL(ctx context.Context, in *UpdatePipelineByURLRequest, opts ...grpc.CallOption) (*UpdatePipelineByURLResponse, error)
	// AbandonPipeline disables a pipeline permanently. This removes all triggers
	// and prevents the pipeline from ever being triggered again.
	AbandonPipeline(ctx context.Context, in *AbandonPipelineRequest, opts ...grpc.CallOption) (*AbandonPipelineResponse, error)
	// GetTrigger returns details about a specific trigger.
	GetTrigger(ctx context.Context, in *GetTriggerRequest, opts ...grpc.CallOption) (*GetTriggerResponse, error)
	// ListTriggers lists all triggers currently registered within gofer.
	ListTriggers(ctx context.Context, in *ListTriggersRequest, opts ...grpc.CallOption) (*ListTriggersResponse, error)
	// GetNotifier returns details about a specific notifier.
	GetNotifier(ctx context.Context, in *GetNotifierRequest, opts ...grpc.CallOption) (*GetNotifierResponse, error)
	// ListNotifiers lists all notifiers currently registered within gofer.
	ListNotifiers(ctx context.Context, in *ListNotifiersRequest, opts ...grpc.CallOption) (*ListNotifiersResponse, error)
	// GetEvent returns the details of a single event.
	GetEvent(ctx context.Context, in *GetEventRequest, opts ...grpc.CallOption) (*GetEventResponse, error)
	// ListEvents returns a streaming list of all events, ordered by
	// oldest to newest.
	ListEvents(ctx context.Context, in *ListEventsRequest, opts ...grpc.CallOption) (Gofer_ListEventsClient, error)
	// GetRun returns the details of a single run.
	GetRun(ctx context.Context, in *GetRunRequest, opts ...grpc.CallOption) (*GetRunResponse, error)
	// BatchGetRuns returns multiple runs by ID.
	BatchGetRuns(ctx context.Context, in *BatchGetRunsRequest, opts ...grpc.CallOption) (*BatchGetRunsResponse, error)
	// ListRuns returns a list of all runs by Pipeline ID. Pagination can be
	// controlled via the offset and limit parameters of the request.
	ListRuns(ctx context.Context, in *ListRunsRequest, opts ...grpc.CallOption) (*ListRunsResponse, error)
	// StartRun starts a new run for the given pipeline. Pipelines that are
	// started via API are marked as such. This RPC has the ability to choose to
	// only run a subset of a pipeline via the "only" flag. Which is not possible
	// via a trigger.
	StartRun(ctx context.Context, in *StartRunRequest, opts ...grpc.CallOption) (*StartRunResponse, error)
	// RetryRun simply takes the vars and settings from a previous run and re-uses
	// those to launch a new run. Useful for if you want the exact settings from a
	// previous run.
	RetryRun(ctx context.Context, in *RetryRunRequest, opts ...grpc.CallOption) (*RetryRunResponse, error)
	// CancelRun stops the execution of a run in progress. Any task runs that
	// might have been running at the time Are ask to stop gracefully(SIGINT)
	// unless the force parameter is used, in which case the task runs are stopped
	// instantly(SIGKILL) and the run is cancelled.
	CancelRun(ctx context.Context, in *CancelRunRequest, opts ...grpc.CallOption) (*CancelRunResponse, error)
	// CancelAllRuns stops the execution of any in-progress runs for a specific
	// pipeline by ID.
	CancelAllRuns(ctx context.Context, in *CancelAllRunsRequest, opts ...grpc.CallOption) (*CancelAllRunsResponse, error)
	// GetTaskRun returns the details of a single task run.
	GetTaskRun(ctx context.Context, in *GetTaskRunRequest, opts ...grpc.CallOption) (*GetTaskRunResponse, error)
	// ListTaskRuns returns all task runs for a current run by ID.
	ListTaskRuns(ctx context.Context, in *ListTaskRunsRequest, opts ...grpc.CallOption) (*ListTaskRunsResponse, error)
	// CancelTaskRun cancels a specific task run, sending the related container a
	// SIGINT signal. If the force flag is used we instead send the container a
	// SIGKILL signal.
	//
	// Task runs that are cancelled can cause other downstream task runs to be
	// skipped depending on those downstream task run dependencies.
	CancelTaskRun(ctx context.Context, in *CancelTaskRunRequest, opts ...grpc.CallOption) (*CancelTaskRunResponse, error)
	// GetTaskRunLogs returns logs for a specific task run line by line in a
	// stream. The logs are returns with both STDOUT and STDERR of the associated
	// container combined.
	GetTaskRunLogs(ctx context.Context, in *GetTaskRunLogsRequest, opts ...grpc.CallOption) (Gofer_GetTaskRunLogsClient, error)
	// DeleteTaskRunLogs removes a task run's associated log object. This is
	// useful for if logs mistakenly contain sensitive data.
	DeleteTaskRunLogs(ctx context.Context, in *DeleteTaskRunLogsRequest, opts ...grpc.CallOption) (*DeleteTaskRunLogsResponse, error)
	// GetPipelineObject returns a single pipeline object by pipeline ID and key.
	GetPipelineObject(ctx context.Context, in *GetPipelineObjectRequest, opts ...grpc.CallOption) (*GetPipelineObjectResponse, error)
	// PutPipelineObject uploads a single pipeline object by pipeline ID and key.
	// Objects which are put under the same key do not count towards the pipeline
	// object limit.
	PutPipelineObject(ctx context.Context, in *PutPipelineObjectRequest, opts ...grpc.CallOption) (*PutPipelineObjectResponse, error)
	// DeletePipelineObject removes a single pipeline object by pipeline ID and
	// key. Removing a pipeline object decrements the total count of the pipeline
	// object limit.
	DeletePipelineObject(ctx context.Context, in *DeletePipelineObjectRequest, opts ...grpc.CallOption) (*DeletePipelineObjectResponse, error)
	// GetRunObject returns the content of a single run object.
	GetRunObject(ctx context.Context, in *GetRunObjectRequest, opts ...grpc.CallOption) (*GetRunObjectResponse, error)
	// PutRunObject uploads the context of an object by run ID and key.
	PutRunObject(ctx context.Context, in *PutRunObjectRequest, opts ...grpc.CallOption) (*PutRunObjectResponse, error)
	// DeleteRunObject removes a specific run object by run ID and key.
	DeleteRunObject(ctx context.Context, in *DeleteRunObjectRequest, opts ...grpc.CallOption) (*DeleteRunObjectResponse, error)
	// GetSecret returns a single secret by pipeline ID and key.
	GetSecret(ctx context.Context, in *GetSecretRequest, opts ...grpc.CallOption) (*GetSecretResponse, error)
	// PutSecret uploads a single secret by pipeline ID and key.
	PutSecret(ctx context.Context, in *PutSecretRequest, opts ...grpc.CallOption) (*PutSecretResponse, error)
	// DeleteSecret removes a single secret by pipeline ID and
	// key.
	DeleteSecret(ctx context.Context, in *DeleteSecretRequest, opts ...grpc.CallOption) (*DeleteSecretResponse, error)
	// GetSystemInfo returns system information and general health.
	GetSystemInfo(ctx context.Context, in *GetSystemInfoRequest, opts ...grpc.CallOption) (*GetSystemInfoResponse, error)
	// RepairOrphan is used when a single run has gotten into a state that does
	// not reflect what actually happened to the run. This can happen if the Gofer
	// service crashes for unforeseen reasons. Usually this route is not needed as
	// Gofer will make an attempt to resolve all orphaned runs upon startup. But
	// in the rare case that a run gets into a bad state during the service's
	// normal execution this route can be used to attempt to repair the orphaned
	// run or at the very least mark it as failed so it isn't stuck in a
	// unfinished state.
	RepairOrphan(ctx context.Context, in *RepairOrphanRequest, opts ...grpc.CallOption) (*RepairOrphanResponse, error)
	// ToggleEventIngress allows the admin to start or stop the execution of all
	// pipelines within Gofer. This can be useful under some security implications
	// or for the purposes of defining general downtime and service maintenance.
	ToggleEventIngress(ctx context.Context, in *ToggleEventIngressRequest, opts ...grpc.CallOption) (*ToggleEventIngressResponse, error)
	// CreateToken manifests a new API token; This token can be a management
	// token(the equivalent of root in Linux) or a client token. Management tokens
	// are the only tokens that can generate tokens.
	// Client tokens are used to manage which namespaces users have access to.
	CreateToken(ctx context.Context, in *CreateTokenRequest, opts ...grpc.CallOption) (*CreateTokenResponse, error)
	// BootstrapToken creates the initial management token used to create all
	// other tokens.
	BootstrapToken(ctx context.Context, in *BootstrapTokenRequest, opts ...grpc.CallOption) (*BootstrapTokenResponse, error)
	// GetToken returns information about a particular token;
	GetToken(ctx context.Context, in *GetTokenRequest, opts ...grpc.CallOption) (*GetTokenResponse, error)
	// DeleteToken removes a token.
	DeleteToken(ctx context.Context, in *DeleteTokenRequest, opts ...grpc.CallOption) (*DeleteTokenResponse, error)
}

type goferClient struct {
	cc grpc.ClientConnInterface
}

func NewGoferClient(cc grpc.ClientConnInterface) GoferClient {
	return &goferClient{cc}
}

func (c *goferClient) ListNamespaces(ctx context.Context, in *ListNamespacesRequest, opts ...grpc.CallOption) (*ListNamespacesResponse, error) {
	out := new(ListNamespacesResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/ListNamespaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) CreateNamespace(ctx context.Context, in *CreateNamespaceRequest, opts ...grpc.CallOption) (*CreateNamespaceResponse, error) {
	out := new(CreateNamespaceResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/CreateNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) GetNamespace(ctx context.Context, in *GetNamespaceRequest, opts ...grpc.CallOption) (*GetNamespaceResponse, error) {
	out := new(GetNamespaceResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/GetNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) UpdateNamespace(ctx context.Context, in *UpdateNamespaceRequest, opts ...grpc.CallOption) (*UpdateNamespaceResponse, error) {
	out := new(UpdateNamespaceResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/UpdateNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) DeleteNamespace(ctx context.Context, in *DeleteNamespaceRequest, opts ...grpc.CallOption) (*DeleteNamespaceResponse, error) {
	out := new(DeleteNamespaceResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/DeleteNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) GetPipeline(ctx context.Context, in *GetPipelineRequest, opts ...grpc.CallOption) (*GetPipelineResponse, error) {
	out := new(GetPipelineResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/GetPipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) ListPipelines(ctx context.Context, in *ListPipelinesRequest, opts ...grpc.CallOption) (*ListPipelinesResponse, error) {
	out := new(ListPipelinesResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/ListPipelines", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) EnablePipeline(ctx context.Context, in *EnablePipelineRequest, opts ...grpc.CallOption) (*EnablePipelineResponse, error) {
	out := new(EnablePipelineResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/EnablePipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) DisablePipeline(ctx context.Context, in *DisablePipelineRequest, opts ...grpc.CallOption) (*DisablePipelineResponse, error) {
	out := new(DisablePipelineResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/DisablePipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) CreatePipelineRaw(ctx context.Context, in *CreatePipelineRawRequest, opts ...grpc.CallOption) (*CreatePipelineRawResponse, error) {
	out := new(CreatePipelineRawResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/CreatePipelineRaw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) CreatePipelineByURL(ctx context.Context, in *CreatePipelineByURLRequest, opts ...grpc.CallOption) (*CreatePipelineByURLResponse, error) {
	out := new(CreatePipelineByURLResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/CreatePipelineByURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) UpdatePipelineRaw(ctx context.Context, in *UpdatePipelineRawRequest, opts ...grpc.CallOption) (*UpdatePipelineRawResponse, error) {
	out := new(UpdatePipelineRawResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/UpdatePipelineRaw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) UpdatePipelineByURL(ctx context.Context, in *UpdatePipelineByURLRequest, opts ...grpc.CallOption) (*UpdatePipelineByURLResponse, error) {
	out := new(UpdatePipelineByURLResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/UpdatePipelineByURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) AbandonPipeline(ctx context.Context, in *AbandonPipelineRequest, opts ...grpc.CallOption) (*AbandonPipelineResponse, error) {
	out := new(AbandonPipelineResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/AbandonPipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) GetTrigger(ctx context.Context, in *GetTriggerRequest, opts ...grpc.CallOption) (*GetTriggerResponse, error) {
	out := new(GetTriggerResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/GetTrigger", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) ListTriggers(ctx context.Context, in *ListTriggersRequest, opts ...grpc.CallOption) (*ListTriggersResponse, error) {
	out := new(ListTriggersResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/ListTriggers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) GetNotifier(ctx context.Context, in *GetNotifierRequest, opts ...grpc.CallOption) (*GetNotifierResponse, error) {
	out := new(GetNotifierResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/GetNotifier", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) ListNotifiers(ctx context.Context, in *ListNotifiersRequest, opts ...grpc.CallOption) (*ListNotifiersResponse, error) {
	out := new(ListNotifiersResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/ListNotifiers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) GetEvent(ctx context.Context, in *GetEventRequest, opts ...grpc.CallOption) (*GetEventResponse, error) {
	out := new(GetEventResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/GetEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) ListEvents(ctx context.Context, in *ListEventsRequest, opts ...grpc.CallOption) (Gofer_ListEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Gofer_ServiceDesc.Streams[0], "/proto.Gofer/ListEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &goferListEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Gofer_ListEventsClient interface {
	Recv() (*ListEventsResponse, error)
	grpc.ClientStream
}

type goferListEventsClient struct {
	grpc.ClientStream
}

func (x *goferListEventsClient) Recv() (*ListEventsResponse, error) {
	m := new(ListEventsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *goferClient) GetRun(ctx context.Context, in *GetRunRequest, opts ...grpc.CallOption) (*GetRunResponse, error) {
	out := new(GetRunResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/GetRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) BatchGetRuns(ctx context.Context, in *BatchGetRunsRequest, opts ...grpc.CallOption) (*BatchGetRunsResponse, error) {
	out := new(BatchGetRunsResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/BatchGetRuns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) ListRuns(ctx context.Context, in *ListRunsRequest, opts ...grpc.CallOption) (*ListRunsResponse, error) {
	out := new(ListRunsResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/ListRuns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) StartRun(ctx context.Context, in *StartRunRequest, opts ...grpc.CallOption) (*StartRunResponse, error) {
	out := new(StartRunResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/StartRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) RetryRun(ctx context.Context, in *RetryRunRequest, opts ...grpc.CallOption) (*RetryRunResponse, error) {
	out := new(RetryRunResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/RetryRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) CancelRun(ctx context.Context, in *CancelRunRequest, opts ...grpc.CallOption) (*CancelRunResponse, error) {
	out := new(CancelRunResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/CancelRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) CancelAllRuns(ctx context.Context, in *CancelAllRunsRequest, opts ...grpc.CallOption) (*CancelAllRunsResponse, error) {
	out := new(CancelAllRunsResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/CancelAllRuns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) GetTaskRun(ctx context.Context, in *GetTaskRunRequest, opts ...grpc.CallOption) (*GetTaskRunResponse, error) {
	out := new(GetTaskRunResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/GetTaskRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) ListTaskRuns(ctx context.Context, in *ListTaskRunsRequest, opts ...grpc.CallOption) (*ListTaskRunsResponse, error) {
	out := new(ListTaskRunsResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/ListTaskRuns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) CancelTaskRun(ctx context.Context, in *CancelTaskRunRequest, opts ...grpc.CallOption) (*CancelTaskRunResponse, error) {
	out := new(CancelTaskRunResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/CancelTaskRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) GetTaskRunLogs(ctx context.Context, in *GetTaskRunLogsRequest, opts ...grpc.CallOption) (Gofer_GetTaskRunLogsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Gofer_ServiceDesc.Streams[1], "/proto.Gofer/GetTaskRunLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &goferGetTaskRunLogsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Gofer_GetTaskRunLogsClient interface {
	Recv() (*GetTaskRunLogsResponse, error)
	grpc.ClientStream
}

type goferGetTaskRunLogsClient struct {
	grpc.ClientStream
}

func (x *goferGetTaskRunLogsClient) Recv() (*GetTaskRunLogsResponse, error) {
	m := new(GetTaskRunLogsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *goferClient) DeleteTaskRunLogs(ctx context.Context, in *DeleteTaskRunLogsRequest, opts ...grpc.CallOption) (*DeleteTaskRunLogsResponse, error) {
	out := new(DeleteTaskRunLogsResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/DeleteTaskRunLogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) GetPipelineObject(ctx context.Context, in *GetPipelineObjectRequest, opts ...grpc.CallOption) (*GetPipelineObjectResponse, error) {
	out := new(GetPipelineObjectResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/GetPipelineObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) PutPipelineObject(ctx context.Context, in *PutPipelineObjectRequest, opts ...grpc.CallOption) (*PutPipelineObjectResponse, error) {
	out := new(PutPipelineObjectResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/PutPipelineObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) DeletePipelineObject(ctx context.Context, in *DeletePipelineObjectRequest, opts ...grpc.CallOption) (*DeletePipelineObjectResponse, error) {
	out := new(DeletePipelineObjectResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/DeletePipelineObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) GetRunObject(ctx context.Context, in *GetRunObjectRequest, opts ...grpc.CallOption) (*GetRunObjectResponse, error) {
	out := new(GetRunObjectResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/GetRunObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) PutRunObject(ctx context.Context, in *PutRunObjectRequest, opts ...grpc.CallOption) (*PutRunObjectResponse, error) {
	out := new(PutRunObjectResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/PutRunObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) DeleteRunObject(ctx context.Context, in *DeleteRunObjectRequest, opts ...grpc.CallOption) (*DeleteRunObjectResponse, error) {
	out := new(DeleteRunObjectResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/DeleteRunObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) GetSecret(ctx context.Context, in *GetSecretRequest, opts ...grpc.CallOption) (*GetSecretResponse, error) {
	out := new(GetSecretResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/GetSecret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) PutSecret(ctx context.Context, in *PutSecretRequest, opts ...grpc.CallOption) (*PutSecretResponse, error) {
	out := new(PutSecretResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/PutSecret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) DeleteSecret(ctx context.Context, in *DeleteSecretRequest, opts ...grpc.CallOption) (*DeleteSecretResponse, error) {
	out := new(DeleteSecretResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/DeleteSecret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) GetSystemInfo(ctx context.Context, in *GetSystemInfoRequest, opts ...grpc.CallOption) (*GetSystemInfoResponse, error) {
	out := new(GetSystemInfoResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/GetSystemInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) RepairOrphan(ctx context.Context, in *RepairOrphanRequest, opts ...grpc.CallOption) (*RepairOrphanResponse, error) {
	out := new(RepairOrphanResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/RepairOrphan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) ToggleEventIngress(ctx context.Context, in *ToggleEventIngressRequest, opts ...grpc.CallOption) (*ToggleEventIngressResponse, error) {
	out := new(ToggleEventIngressResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/ToggleEventIngress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) CreateToken(ctx context.Context, in *CreateTokenRequest, opts ...grpc.CallOption) (*CreateTokenResponse, error) {
	out := new(CreateTokenResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/CreateToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) BootstrapToken(ctx context.Context, in *BootstrapTokenRequest, opts ...grpc.CallOption) (*BootstrapTokenResponse, error) {
	out := new(BootstrapTokenResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/BootstrapToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) GetToken(ctx context.Context, in *GetTokenRequest, opts ...grpc.CallOption) (*GetTokenResponse, error) {
	out := new(GetTokenResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/GetToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goferClient) DeleteToken(ctx context.Context, in *DeleteTokenRequest, opts ...grpc.CallOption) (*DeleteTokenResponse, error) {
	out := new(DeleteTokenResponse)
	err := c.cc.Invoke(ctx, "/proto.Gofer/DeleteToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GoferServer is the server API for Gofer service.
// All implementations must embed UnimplementedGoferServer
// for forward compatibility
type GoferServer interface {
	// ListNamespaces returns all registered namespaces.
	ListNamespaces(context.Context, *ListNamespacesRequest) (*ListNamespacesResponse, error)
	// CreateNamespace creates a new namespace that separates pipelines.
	CreateNamespace(context.Context, *CreateNamespaceRequest) (*CreateNamespaceResponse, error)
	// GetNamespace returns a single namespace by id.
	GetNamespace(context.Context, *GetNamespaceRequest) (*GetNamespaceResponse, error)
	// UpdateNamespace updates the details of a particular namespace by id.
	UpdateNamespace(context.Context, *UpdateNamespaceRequest) (*UpdateNamespaceResponse, error)
	// DeleteNamespace removes a namespace by id.
	DeleteNamespace(context.Context, *DeleteNamespaceRequest) (*DeleteNamespaceResponse, error)
	// GetPipeline returns a single pipeline by ID.
	GetPipeline(context.Context, *GetPipelineRequest) (*GetPipelineResponse, error)
	// ListPipelines returns all registered pipelines. Can control pagination by
	// offset && limit request parameters.
	// By default ListPipelines will return the first 100 pipelines ordered by
	// creation.
	ListPipelines(context.Context, *ListPipelinesRequest) (*ListPipelinesResponse, error)
	// EnablePipeline allows a pipeline to execute runs by allowing it to receive
	// trigger events. See DisablePipeline to prevent a pipeline from executing
	// any more runs.
	EnablePipeline(context.Context, *EnablePipelineRequest) (*EnablePipelineResponse, error)
	// DisablePipeline prevents the pipeline from executing runs. Any trigger
	// events that would normally cause the pipeline to be run are instead
	// discarded.
	DisablePipeline(context.Context, *DisablePipelineRequest) (*DisablePipelineResponse, error)
	// CreatePipelineRaw creates a new pipeline from a raw byte string
	// representation of a pipeline config file. This is useful if you're
	// attempting to create the pipeline from a source that is not held in source
	// control or maybe not publicly available.
	CreatePipelineRaw(context.Context, *CreatePipelineRawRequest) (*CreatePipelineRawResponse, error)
	// CreatePipelineByURL creates a new pipeline from a pipeline config stored
	// remotely. Many forms of a remote URL can be used here. You can view a full
	// list of accepted protocols and extra options here:
	// https://github.com/hashicorp/go-getter#general-all-protocols
	CreatePipelineByURL(context.Context, *CreatePipelineByURLRequest) (*CreatePipelineByURLResponse, error)
	// UpdatePipelineRaw updates a pipeline by raw byte string representation of a
	// pipeline config file. Updating a pipeline requires the pipeline to adhere
	// to two states:
	//    1) The pipeline must not have any current runs in progress.
	//    2) The pipeline must be in a disabled state.
	UpdatePipelineRaw(context.Context, *UpdatePipelineRawRequest) (*UpdatePipelineRawResponse, error)
	// UpdatePipelineByURL updates a pipeline from a pipeline config stored
	// remotely. Many forms of a remote URL can be used. You can view a full list
	// of accepted protocols and extra options here:
	// https://github.com/hashicorp/go-getter#general-all-protocols
	//
	// In order to update the pipeline, it must adhere to two states:
	//    1) The pipeline must not have any current runs in progress.
	//    2) The pipeline must be in a disabled state.
	UpdatePipelineByURL(context.Context, *UpdatePipelineByURLRequest) (*UpdatePipelineByURLResponse, error)
	// AbandonPipeline disables a pipeline permanently. This removes all triggers
	// and prevents the pipeline from ever being triggered again.
	AbandonPipeline(context.Context, *AbandonPipelineRequest) (*AbandonPipelineResponse, error)
	// GetTrigger returns details about a specific trigger.
	GetTrigger(context.Context, *GetTriggerRequest) (*GetTriggerResponse, error)
	// ListTriggers lists all triggers currently registered within gofer.
	ListTriggers(context.Context, *ListTriggersRequest) (*ListTriggersResponse, error)
	// GetNotifier returns details about a specific notifier.
	GetNotifier(context.Context, *GetNotifierRequest) (*GetNotifierResponse, error)
	// ListNotifiers lists all notifiers currently registered within gofer.
	ListNotifiers(context.Context, *ListNotifiersRequest) (*ListNotifiersResponse, error)
	// GetEvent returns the details of a single event.
	GetEvent(context.Context, *GetEventRequest) (*GetEventResponse, error)
	// ListEvents returns a streaming list of all events, ordered by
	// oldest to newest.
	ListEvents(*ListEventsRequest, Gofer_ListEventsServer) error
	// GetRun returns the details of a single run.
	GetRun(context.Context, *GetRunRequest) (*GetRunResponse, error)
	// BatchGetRuns returns multiple runs by ID.
	BatchGetRuns(context.Context, *BatchGetRunsRequest) (*BatchGetRunsResponse, error)
	// ListRuns returns a list of all runs by Pipeline ID. Pagination can be
	// controlled via the offset and limit parameters of the request.
	ListRuns(context.Context, *ListRunsRequest) (*ListRunsResponse, error)
	// StartRun starts a new run for the given pipeline. Pipelines that are
	// started via API are marked as such. This RPC has the ability to choose to
	// only run a subset of a pipeline via the "only" flag. Which is not possible
	// via a trigger.
	StartRun(context.Context, *StartRunRequest) (*StartRunResponse, error)
	// RetryRun simply takes the vars and settings from a previous run and re-uses
	// those to launch a new run. Useful for if you want the exact settings from a
	// previous run.
	RetryRun(context.Context, *RetryRunRequest) (*RetryRunResponse, error)
	// CancelRun stops the execution of a run in progress. Any task runs that
	// might have been running at the time Are ask to stop gracefully(SIGINT)
	// unless the force parameter is used, in which case the task runs are stopped
	// instantly(SIGKILL) and the run is cancelled.
	CancelRun(context.Context, *CancelRunRequest) (*CancelRunResponse, error)
	// CancelAllRuns stops the execution of any in-progress runs for a specific
	// pipeline by ID.
	CancelAllRuns(context.Context, *CancelAllRunsRequest) (*CancelAllRunsResponse, error)
	// GetTaskRun returns the details of a single task run.
	GetTaskRun(context.Context, *GetTaskRunRequest) (*GetTaskRunResponse, error)
	// ListTaskRuns returns all task runs for a current run by ID.
	ListTaskRuns(context.Context, *ListTaskRunsRequest) (*ListTaskRunsResponse, error)
	// CancelTaskRun cancels a specific task run, sending the related container a
	// SIGINT signal. If the force flag is used we instead send the container a
	// SIGKILL signal.
	//
	// Task runs that are cancelled can cause other downstream task runs to be
	// skipped depending on those downstream task run dependencies.
	CancelTaskRun(context.Context, *CancelTaskRunRequest) (*CancelTaskRunResponse, error)
	// GetTaskRunLogs returns logs for a specific task run line by line in a
	// stream. The logs are returns with both STDOUT and STDERR of the associated
	// container combined.
	GetTaskRunLogs(*GetTaskRunLogsRequest, Gofer_GetTaskRunLogsServer) error
	// DeleteTaskRunLogs removes a task run's associated log object. This is
	// useful for if logs mistakenly contain sensitive data.
	DeleteTaskRunLogs(context.Context, *DeleteTaskRunLogsRequest) (*DeleteTaskRunLogsResponse, error)
	// GetPipelineObject returns a single pipeline object by pipeline ID and key.
	GetPipelineObject(context.Context, *GetPipelineObjectRequest) (*GetPipelineObjectResponse, error)
	// PutPipelineObject uploads a single pipeline object by pipeline ID and key.
	// Objects which are put under the same key do not count towards the pipeline
	// object limit.
	PutPipelineObject(context.Context, *PutPipelineObjectRequest) (*PutPipelineObjectResponse, error)
	// DeletePipelineObject removes a single pipeline object by pipeline ID and
	// key. Removing a pipeline object decrements the total count of the pipeline
	// object limit.
	DeletePipelineObject(context.Context, *DeletePipelineObjectRequest) (*DeletePipelineObjectResponse, error)
	// GetRunObject returns the content of a single run object.
	GetRunObject(context.Context, *GetRunObjectRequest) (*GetRunObjectResponse, error)
	// PutRunObject uploads the context of an object by run ID and key.
	PutRunObject(context.Context, *PutRunObjectRequest) (*PutRunObjectResponse, error)
	// DeleteRunObject removes a specific run object by run ID and key.
	DeleteRunObject(context.Context, *DeleteRunObjectRequest) (*DeleteRunObjectResponse, error)
	// GetSecret returns a single secret by pipeline ID and key.
	GetSecret(context.Context, *GetSecretRequest) (*GetSecretResponse, error)
	// PutSecret uploads a single secret by pipeline ID and key.
	PutSecret(context.Context, *PutSecretRequest) (*PutSecretResponse, error)
	// DeleteSecret removes a single secret by pipeline ID and
	// key.
	DeleteSecret(context.Context, *DeleteSecretRequest) (*DeleteSecretResponse, error)
	// GetSystemInfo returns system information and general health.
	GetSystemInfo(context.Context, *GetSystemInfoRequest) (*GetSystemInfoResponse, error)
	// RepairOrphan is used when a single run has gotten into a state that does
	// not reflect what actually happened to the run. This can happen if the Gofer
	// service crashes for unforeseen reasons. Usually this route is not needed as
	// Gofer will make an attempt to resolve all orphaned runs upon startup. But
	// in the rare case that a run gets into a bad state during the service's
	// normal execution this route can be used to attempt to repair the orphaned
	// run or at the very least mark it as failed so it isn't stuck in a
	// unfinished state.
	RepairOrphan(context.Context, *RepairOrphanRequest) (*RepairOrphanResponse, error)
	// ToggleEventIngress allows the admin to start or stop the execution of all
	// pipelines within Gofer. This can be useful under some security implications
	// or for the purposes of defining general downtime and service maintenance.
	ToggleEventIngress(context.Context, *ToggleEventIngressRequest) (*ToggleEventIngressResponse, error)
	// CreateToken manifests a new API token; This token can be a management
	// token(the equivalent of root in Linux) or a client token. Management tokens
	// are the only tokens that can generate tokens.
	// Client tokens are used to manage which namespaces users have access to.
	CreateToken(context.Context, *CreateTokenRequest) (*CreateTokenResponse, error)
	// BootstrapToken creates the initial management token used to create all
	// other tokens.
	BootstrapToken(context.Context, *BootstrapTokenRequest) (*BootstrapTokenResponse, error)
	// GetToken returns information about a particular token;
	GetToken(context.Context, *GetTokenRequest) (*GetTokenResponse, error)
	// DeleteToken removes a token.
	DeleteToken(context.Context, *DeleteTokenRequest) (*DeleteTokenResponse, error)
	mustEmbedUnimplementedGoferServer()
}

// UnimplementedGoferServer must be embedded to have forward compatible implementations.
type UnimplementedGoferServer struct {
}

func (UnimplementedGoferServer) ListNamespaces(context.Context, *ListNamespacesRequest) (*ListNamespacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNamespaces not implemented")
}
func (UnimplementedGoferServer) CreateNamespace(context.Context, *CreateNamespaceRequest) (*CreateNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNamespace not implemented")
}
func (UnimplementedGoferServer) GetNamespace(context.Context, *GetNamespaceRequest) (*GetNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNamespace not implemented")
}
func (UnimplementedGoferServer) UpdateNamespace(context.Context, *UpdateNamespaceRequest) (*UpdateNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNamespace not implemented")
}
func (UnimplementedGoferServer) DeleteNamespace(context.Context, *DeleteNamespaceRequest) (*DeleteNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNamespace not implemented")
}
func (UnimplementedGoferServer) GetPipeline(context.Context, *GetPipelineRequest) (*GetPipelineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPipeline not implemented")
}
func (UnimplementedGoferServer) ListPipelines(context.Context, *ListPipelinesRequest) (*ListPipelinesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPipelines not implemented")
}
func (UnimplementedGoferServer) EnablePipeline(context.Context, *EnablePipelineRequest) (*EnablePipelineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnablePipeline not implemented")
}
func (UnimplementedGoferServer) DisablePipeline(context.Context, *DisablePipelineRequest) (*DisablePipelineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisablePipeline not implemented")
}
func (UnimplementedGoferServer) CreatePipelineRaw(context.Context, *CreatePipelineRawRequest) (*CreatePipelineRawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePipelineRaw not implemented")
}
func (UnimplementedGoferServer) CreatePipelineByURL(context.Context, *CreatePipelineByURLRequest) (*CreatePipelineByURLResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePipelineByURL not implemented")
}
func (UnimplementedGoferServer) UpdatePipelineRaw(context.Context, *UpdatePipelineRawRequest) (*UpdatePipelineRawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePipelineRaw not implemented")
}
func (UnimplementedGoferServer) UpdatePipelineByURL(context.Context, *UpdatePipelineByURLRequest) (*UpdatePipelineByURLResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePipelineByURL not implemented")
}
func (UnimplementedGoferServer) AbandonPipeline(context.Context, *AbandonPipelineRequest) (*AbandonPipelineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbandonPipeline not implemented")
}
func (UnimplementedGoferServer) GetTrigger(context.Context, *GetTriggerRequest) (*GetTriggerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrigger not implemented")
}
func (UnimplementedGoferServer) ListTriggers(context.Context, *ListTriggersRequest) (*ListTriggersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTriggers not implemented")
}
func (UnimplementedGoferServer) GetNotifier(context.Context, *GetNotifierRequest) (*GetNotifierResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotifier not implemented")
}
func (UnimplementedGoferServer) ListNotifiers(context.Context, *ListNotifiersRequest) (*ListNotifiersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotifiers not implemented")
}
func (UnimplementedGoferServer) GetEvent(context.Context, *GetEventRequest) (*GetEventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEvent not implemented")
}
func (UnimplementedGoferServer) ListEvents(*ListEventsRequest, Gofer_ListEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListEvents not implemented")
}
func (UnimplementedGoferServer) GetRun(context.Context, *GetRunRequest) (*GetRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRun not implemented")
}
func (UnimplementedGoferServer) BatchGetRuns(context.Context, *BatchGetRunsRequest) (*BatchGetRunsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGetRuns not implemented")
}
func (UnimplementedGoferServer) ListRuns(context.Context, *ListRunsRequest) (*ListRunsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRuns not implemented")
}
func (UnimplementedGoferServer) StartRun(context.Context, *StartRunRequest) (*StartRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartRun not implemented")
}
func (UnimplementedGoferServer) RetryRun(context.Context, *RetryRunRequest) (*RetryRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetryRun not implemented")
}
func (UnimplementedGoferServer) CancelRun(context.Context, *CancelRunRequest) (*CancelRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelRun not implemented")
}
func (UnimplementedGoferServer) CancelAllRuns(context.Context, *CancelAllRunsRequest) (*CancelAllRunsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelAllRuns not implemented")
}
func (UnimplementedGoferServer) GetTaskRun(context.Context, *GetTaskRunRequest) (*GetTaskRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTaskRun not implemented")
}
func (UnimplementedGoferServer) ListTaskRuns(context.Context, *ListTaskRunsRequest) (*ListTaskRunsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTaskRuns not implemented")
}
func (UnimplementedGoferServer) CancelTaskRun(context.Context, *CancelTaskRunRequest) (*CancelTaskRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelTaskRun not implemented")
}
func (UnimplementedGoferServer) GetTaskRunLogs(*GetTaskRunLogsRequest, Gofer_GetTaskRunLogsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTaskRunLogs not implemented")
}
func (UnimplementedGoferServer) DeleteTaskRunLogs(context.Context, *DeleteTaskRunLogsRequest) (*DeleteTaskRunLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTaskRunLogs not implemented")
}
func (UnimplementedGoferServer) GetPipelineObject(context.Context, *GetPipelineObjectRequest) (*GetPipelineObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPipelineObject not implemented")
}
func (UnimplementedGoferServer) PutPipelineObject(context.Context, *PutPipelineObjectRequest) (*PutPipelineObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutPipelineObject not implemented")
}
func (UnimplementedGoferServer) DeletePipelineObject(context.Context, *DeletePipelineObjectRequest) (*DeletePipelineObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePipelineObject not implemented")
}
func (UnimplementedGoferServer) GetRunObject(context.Context, *GetRunObjectRequest) (*GetRunObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRunObject not implemented")
}
func (UnimplementedGoferServer) PutRunObject(context.Context, *PutRunObjectRequest) (*PutRunObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutRunObject not implemented")
}
func (UnimplementedGoferServer) DeleteRunObject(context.Context, *DeleteRunObjectRequest) (*DeleteRunObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRunObject not implemented")
}
func (UnimplementedGoferServer) GetSecret(context.Context, *GetSecretRequest) (*GetSecretResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSecret not implemented")
}
func (UnimplementedGoferServer) PutSecret(context.Context, *PutSecretRequest) (*PutSecretResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutSecret not implemented")
}
func (UnimplementedGoferServer) DeleteSecret(context.Context, *DeleteSecretRequest) (*DeleteSecretResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSecret not implemented")
}
func (UnimplementedGoferServer) GetSystemInfo(context.Context, *GetSystemInfoRequest) (*GetSystemInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemInfo not implemented")
}
func (UnimplementedGoferServer) RepairOrphan(context.Context, *RepairOrphanRequest) (*RepairOrphanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RepairOrphan not implemented")
}
func (UnimplementedGoferServer) ToggleEventIngress(context.Context, *ToggleEventIngressRequest) (*ToggleEventIngressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToggleEventIngress not implemented")
}
func (UnimplementedGoferServer) CreateToken(context.Context, *CreateTokenRequest) (*CreateTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateToken not implemented")
}
func (UnimplementedGoferServer) BootstrapToken(context.Context, *BootstrapTokenRequest) (*BootstrapTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BootstrapToken not implemented")
}
func (UnimplementedGoferServer) GetToken(context.Context, *GetTokenRequest) (*GetTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetToken not implemented")
}
func (UnimplementedGoferServer) DeleteToken(context.Context, *DeleteTokenRequest) (*DeleteTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteToken not implemented")
}
func (UnimplementedGoferServer) mustEmbedUnimplementedGoferServer() {}

// UnsafeGoferServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GoferServer will
// result in compilation errors.
type UnsafeGoferServer interface {
	mustEmbedUnimplementedGoferServer()
}

func RegisterGoferServer(s grpc.ServiceRegistrar, srv GoferServer) {
	s.RegisterService(&Gofer_ServiceDesc, srv)
}

func _Gofer_ListNamespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNamespacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).ListNamespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/ListNamespaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).ListNamespaces(ctx, req.(*ListNamespacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_CreateNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).CreateNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/CreateNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).CreateNamespace(ctx, req.(*CreateNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_GetNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).GetNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/GetNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).GetNamespace(ctx, req.(*GetNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_UpdateNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).UpdateNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/UpdateNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).UpdateNamespace(ctx, req.(*UpdateNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_DeleteNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).DeleteNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/DeleteNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).DeleteNamespace(ctx, req.(*DeleteNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_GetPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).GetPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/GetPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).GetPipeline(ctx, req.(*GetPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_ListPipelines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPipelinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).ListPipelines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/ListPipelines",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).ListPipelines(ctx, req.(*ListPipelinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_EnablePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnablePipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).EnablePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/EnablePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).EnablePipeline(ctx, req.(*EnablePipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_DisablePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisablePipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).DisablePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/DisablePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).DisablePipeline(ctx, req.(*DisablePipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_CreatePipelineRaw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePipelineRawRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).CreatePipelineRaw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/CreatePipelineRaw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).CreatePipelineRaw(ctx, req.(*CreatePipelineRawRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_CreatePipelineByURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePipelineByURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).CreatePipelineByURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/CreatePipelineByURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).CreatePipelineByURL(ctx, req.(*CreatePipelineByURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_UpdatePipelineRaw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePipelineRawRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).UpdatePipelineRaw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/UpdatePipelineRaw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).UpdatePipelineRaw(ctx, req.(*UpdatePipelineRawRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_UpdatePipelineByURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePipelineByURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).UpdatePipelineByURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/UpdatePipelineByURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).UpdatePipelineByURL(ctx, req.(*UpdatePipelineByURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_AbandonPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbandonPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).AbandonPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/AbandonPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).AbandonPipeline(ctx, req.(*AbandonPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_GetTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTriggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).GetTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/GetTrigger",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).GetTrigger(ctx, req.(*GetTriggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_ListTriggers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTriggersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).ListTriggers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/ListTriggers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).ListTriggers(ctx, req.(*ListTriggersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_GetNotifier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNotifierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).GetNotifier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/GetNotifier",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).GetNotifier(ctx, req.(*GetNotifierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_ListNotifiers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNotifiersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).ListNotifiers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/ListNotifiers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).ListNotifiers(ctx, req.(*ListNotifiersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_GetEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).GetEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/GetEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).GetEvent(ctx, req.(*GetEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_ListEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GoferServer).ListEvents(m, &goferListEventsServer{stream})
}

type Gofer_ListEventsServer interface {
	Send(*ListEventsResponse) error
	grpc.ServerStream
}

type goferListEventsServer struct {
	grpc.ServerStream
}

func (x *goferListEventsServer) Send(m *ListEventsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Gofer_GetRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).GetRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/GetRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).GetRun(ctx, req.(*GetRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_BatchGetRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGetRunsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).BatchGetRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/BatchGetRuns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).BatchGetRuns(ctx, req.(*BatchGetRunsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_ListRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRunsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).ListRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/ListRuns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).ListRuns(ctx, req.(*ListRunsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_StartRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).StartRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/StartRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).StartRun(ctx, req.(*StartRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_RetryRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetryRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).RetryRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/RetryRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).RetryRun(ctx, req.(*RetryRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_CancelRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).CancelRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/CancelRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).CancelRun(ctx, req.(*CancelRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_CancelAllRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelAllRunsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).CancelAllRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/CancelAllRuns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).CancelAllRuns(ctx, req.(*CancelAllRunsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_GetTaskRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).GetTaskRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/GetTaskRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).GetTaskRun(ctx, req.(*GetTaskRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_ListTaskRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTaskRunsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).ListTaskRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/ListTaskRuns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).ListTaskRuns(ctx, req.(*ListTaskRunsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_CancelTaskRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelTaskRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).CancelTaskRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/CancelTaskRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).CancelTaskRun(ctx, req.(*CancelTaskRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_GetTaskRunLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetTaskRunLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GoferServer).GetTaskRunLogs(m, &goferGetTaskRunLogsServer{stream})
}

type Gofer_GetTaskRunLogsServer interface {
	Send(*GetTaskRunLogsResponse) error
	grpc.ServerStream
}

type goferGetTaskRunLogsServer struct {
	grpc.ServerStream
}

func (x *goferGetTaskRunLogsServer) Send(m *GetTaskRunLogsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Gofer_DeleteTaskRunLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTaskRunLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).DeleteTaskRunLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/DeleteTaskRunLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).DeleteTaskRunLogs(ctx, req.(*DeleteTaskRunLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_GetPipelineObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPipelineObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).GetPipelineObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/GetPipelineObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).GetPipelineObject(ctx, req.(*GetPipelineObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_PutPipelineObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutPipelineObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).PutPipelineObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/PutPipelineObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).PutPipelineObject(ctx, req.(*PutPipelineObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_DeletePipelineObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePipelineObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).DeletePipelineObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/DeletePipelineObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).DeletePipelineObject(ctx, req.(*DeletePipelineObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_GetRunObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRunObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).GetRunObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/GetRunObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).GetRunObject(ctx, req.(*GetRunObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_PutRunObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutRunObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).PutRunObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/PutRunObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).PutRunObject(ctx, req.(*PutRunObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_DeleteRunObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRunObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).DeleteRunObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/DeleteRunObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).DeleteRunObject(ctx, req.(*DeleteRunObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_GetSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).GetSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/GetSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).GetSecret(ctx, req.(*GetSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_PutSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).PutSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/PutSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).PutSecret(ctx, req.(*PutSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_DeleteSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).DeleteSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/DeleteSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).DeleteSecret(ctx, req.(*DeleteSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_GetSystemInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSystemInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).GetSystemInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/GetSystemInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).GetSystemInfo(ctx, req.(*GetSystemInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_RepairOrphan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepairOrphanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).RepairOrphan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/RepairOrphan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).RepairOrphan(ctx, req.(*RepairOrphanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_ToggleEventIngress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToggleEventIngressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).ToggleEventIngress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/ToggleEventIngress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).ToggleEventIngress(ctx, req.(*ToggleEventIngressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_CreateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).CreateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/CreateToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).CreateToken(ctx, req.(*CreateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_BootstrapToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BootstrapTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).BootstrapToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/BootstrapToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).BootstrapToken(ctx, req.(*BootstrapTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_GetToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).GetToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/GetToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).GetToken(ctx, req.(*GetTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gofer_DeleteToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoferServer).DeleteToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Gofer/DeleteToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoferServer).DeleteToken(ctx, req.(*DeleteTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Gofer_ServiceDesc is the grpc.ServiceDesc for Gofer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Gofer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Gofer",
	HandlerType: (*GoferServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListNamespaces",
			Handler:    _Gofer_ListNamespaces_Handler,
		},
		{
			MethodName: "CreateNamespace",
			Handler:    _Gofer_CreateNamespace_Handler,
		},
		{
			MethodName: "GetNamespace",
			Handler:    _Gofer_GetNamespace_Handler,
		},
		{
			MethodName: "UpdateNamespace",
			Handler:    _Gofer_UpdateNamespace_Handler,
		},
		{
			MethodName: "DeleteNamespace",
			Handler:    _Gofer_DeleteNamespace_Handler,
		},
		{
			MethodName: "GetPipeline",
			Handler:    _Gofer_GetPipeline_Handler,
		},
		{
			MethodName: "ListPipelines",
			Handler:    _Gofer_ListPipelines_Handler,
		},
		{
			MethodName: "EnablePipeline",
			Handler:    _Gofer_EnablePipeline_Handler,
		},
		{
			MethodName: "DisablePipeline",
			Handler:    _Gofer_DisablePipeline_Handler,
		},
		{
			MethodName: "CreatePipelineRaw",
			Handler:    _Gofer_CreatePipelineRaw_Handler,
		},
		{
			MethodName: "CreatePipelineByURL",
			Handler:    _Gofer_CreatePipelineByURL_Handler,
		},
		{
			MethodName: "UpdatePipelineRaw",
			Handler:    _Gofer_UpdatePipelineRaw_Handler,
		},
		{
			MethodName: "UpdatePipelineByURL",
			Handler:    _Gofer_UpdatePipelineByURL_Handler,
		},
		{
			MethodName: "AbandonPipeline",
			Handler:    _Gofer_AbandonPipeline_Handler,
		},
		{
			MethodName: "GetTrigger",
			Handler:    _Gofer_GetTrigger_Handler,
		},
		{
			MethodName: "ListTriggers",
			Handler:    _Gofer_ListTriggers_Handler,
		},
		{
			MethodName: "GetNotifier",
			Handler:    _Gofer_GetNotifier_Handler,
		},
		{
			MethodName: "ListNotifiers",
			Handler:    _Gofer_ListNotifiers_Handler,
		},
		{
			MethodName: "GetEvent",
			Handler:    _Gofer_GetEvent_Handler,
		},
		{
			MethodName: "GetRun",
			Handler:    _Gofer_GetRun_Handler,
		},
		{
			MethodName: "BatchGetRuns",
			Handler:    _Gofer_BatchGetRuns_Handler,
		},
		{
			MethodName: "ListRuns",
			Handler:    _Gofer_ListRuns_Handler,
		},
		{
			MethodName: "StartRun",
			Handler:    _Gofer_StartRun_Handler,
		},
		{
			MethodName: "RetryRun",
			Handler:    _Gofer_RetryRun_Handler,
		},
		{
			MethodName: "CancelRun",
			Handler:    _Gofer_CancelRun_Handler,
		},
		{
			MethodName: "CancelAllRuns",
			Handler:    _Gofer_CancelAllRuns_Handler,
		},
		{
			MethodName: "GetTaskRun",
			Handler:    _Gofer_GetTaskRun_Handler,
		},
		{
			MethodName: "ListTaskRuns",
			Handler:    _Gofer_ListTaskRuns_Handler,
		},
		{
			MethodName: "CancelTaskRun",
			Handler:    _Gofer_CancelTaskRun_Handler,
		},
		{
			MethodName: "DeleteTaskRunLogs",
			Handler:    _Gofer_DeleteTaskRunLogs_Handler,
		},
		{
			MethodName: "GetPipelineObject",
			Handler:    _Gofer_GetPipelineObject_Handler,
		},
		{
			MethodName: "PutPipelineObject",
			Handler:    _Gofer_PutPipelineObject_Handler,
		},
		{
			MethodName: "DeletePipelineObject",
			Handler:    _Gofer_DeletePipelineObject_Handler,
		},
		{
			MethodName: "GetRunObject",
			Handler:    _Gofer_GetRunObject_Handler,
		},
		{
			MethodName: "PutRunObject",
			Handler:    _Gofer_PutRunObject_Handler,
		},
		{
			MethodName: "DeleteRunObject",
			Handler:    _Gofer_DeleteRunObject_Handler,
		},
		{
			MethodName: "GetSecret",
			Handler:    _Gofer_GetSecret_Handler,
		},
		{
			MethodName: "PutSecret",
			Handler:    _Gofer_PutSecret_Handler,
		},
		{
			MethodName: "DeleteSecret",
			Handler:    _Gofer_DeleteSecret_Handler,
		},
		{
			MethodName: "GetSystemInfo",
			Handler:    _Gofer_GetSystemInfo_Handler,
		},
		{
			MethodName: "RepairOrphan",
			Handler:    _Gofer_RepairOrphan_Handler,
		},
		{
			MethodName: "ToggleEventIngress",
			Handler:    _Gofer_ToggleEventIngress_Handler,
		},
		{
			MethodName: "CreateToken",
			Handler:    _Gofer_CreateToken_Handler,
		},
		{
			MethodName: "BootstrapToken",
			Handler:    _Gofer_BootstrapToken_Handler,
		},
		{
			MethodName: "GetToken",
			Handler:    _Gofer_GetToken_Handler,
		},
		{
			MethodName: "DeleteToken",
			Handler:    _Gofer_DeleteToken_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListEvents",
			Handler:       _Gofer_ListEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetTaskRunLogs",
			Handler:       _Gofer_GetTaskRunLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "gofer.proto",
}
