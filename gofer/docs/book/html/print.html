<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gofer</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Gofer documentation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="how_does_gofer_work.html">How Does Gofer Work?</a></li><li class="chapter-item expanded affix "><a href="glossary.html">Glossary</a></li><li class="chapter-item expanded affix "><a href="faq.html">FAQ</a></li><li class="chapter-item expanded affix "><a href="features.html">Feature Guide</a></li><li class="chapter-item expanded affix "><a href="best_practices.html">Best Practices</a></li><li class="chapter-item expanded affix "><a href="troubleshooting.html">Troubleshooting</a></li><li class="chapter-item expanded affix "><a href="philosophy.html">Philosophy</a></li><li class="chapter-item expanded affix "><a href="api_reference.html">API Reference</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="guide/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guide/installing_gofer.html"><strong aria-hidden="true">1.1.</strong> Installing Gofer</a></li><li class="chapter-item expanded "><a href="guide/running_the_server_locally.html"><strong aria-hidden="true">1.2.</strong> Running the Server Locally</a></li><li class="chapter-item expanded "><a href="guide/create_your_first_pipeline_configuration.html"><strong aria-hidden="true">1.3.</strong> Create Your First Pipeline Config</a></li><li class="chapter-item expanded "><a href="guide/register_your_pipeline.html"><strong aria-hidden="true">1.4.</strong> Register your pipeline</a></li><li class="chapter-item expanded "><a href="guide/start_a_run.html"><strong aria-hidden="true">1.5.</strong> Start a Run</a></li><li class="chapter-item expanded "><a href="guide/whats_next.html"><strong aria-hidden="true">1.6.</strong> What's Next?</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="ref/pipeline_configuration/index.html"><strong aria-hidden="true">2.</strong> Pipeline Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ref/pipeline_configuration/tasks.html"><strong aria-hidden="true">2.1.</strong> Tasks</a></li></ol></li><li class="chapter-item expanded "><a href="ref/server_configuration/index.html"><strong aria-hidden="true">3.</strong> Server Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ref/server_configuration/configuration_reference.html"><strong aria-hidden="true">3.1.</strong> Configuration Reference</a></li><li class="chapter-item expanded "><a href="ref/server_configuration/authentication.html"><strong aria-hidden="true">3.2.</strong> Authentication</a></li><li class="chapter-item expanded "><a href="ref/server_configuration/external_events.html"><strong aria-hidden="true">3.3.</strong> External Events</a></li></ol></li><li class="chapter-item expanded "><a href="ref/scheduler/index.html"><strong aria-hidden="true">4.</strong> Scheduler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ref/scheduler/docker.html"><strong aria-hidden="true">4.1.</strong> Docker</a></li></ol></li><li class="chapter-item expanded "><a href="ref/object_store/index.html"><strong aria-hidden="true">5.</strong> Object Store</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ref/object_store/sqlite.html"><strong aria-hidden="true">5.1.</strong> Sqlite</a></li></ol></li><li class="chapter-item expanded "><a href="ref/secret_store/index.html"><strong aria-hidden="true">6.</strong> Secret Store</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ref/secret_store/sqlite.html"><strong aria-hidden="true">6.1.</strong> Sqlite</a></li></ol></li><li class="chapter-item expanded "><a href="ref/extensions/index.html"><strong aria-hidden="true">7.</strong> Extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ref/extensions/provided/index.html"><strong aria-hidden="true">7.1.</strong> Provided Extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ref/extensions/provided/cron.html"><strong aria-hidden="true">7.1.1.</strong> Cron</a></li><li class="chapter-item expanded "><a href="ref/extensions/provided/interval.html"><strong aria-hidden="true">7.1.2.</strong> Interval</a></li><li class="chapter-item expanded "><a href="ref/extensions/provided/github.html"><strong aria-hidden="true">7.1.3.</strong> Github</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">CLI</li><li class="chapter-item expanded "><a href="cli/index.html"><strong aria-hidden="true">8.</strong> Command Line</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cli/configuration.html"><strong aria-hidden="true">8.1.</strong> Configuration</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Gofer</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/clintjedwards/gofer" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Gofer documentation! This documentation is a reference for all available features and options of Gofer.</p>
<ul>
<li>To kick the tires visit: <a href="./guide/index.html">Getting Started</a></li>
<li>To read more about Gofer's Feature set visit: <a href="./features.html">Features</a></li>
<li>To understand the why of Gofer visit: <a href="./philosophy.html">Philosophy</a></li>
</ul>
<h1 id="gofer-run-short-lived-jobs-easily"><a class="header" href="#gofer-run-short-lived-jobs-easily"><a href="https://clintjedwards.com/gofer/assets/urban_dictionary_gofer.png">Gofer</a>: Run short-lived jobs easily.</a></h1>
<p align="center">
    <img src="https://clintjedwards.com/gofer/assets/logo-name-hq.png" alt="gofer" width="200"/>
</p>
<p><img src="https://img.shields.io/badge/docs-learn%20more-3498db?style=flat-square" alt="website-badge" />
<img src="https://img.shields.io/badge/Project%20Status-Alpha-orange?style=flat-square" alt="project status" /></p>
<p>Gofer is an opinionated, streamlined automation engine designed for the cloud-native era. It's basically remote code execution as a platform.</p>
<p>It specializes in executing your custom scripts in a containerized environment, making it versatile for both developers and operations teams. Deploy Gofer effortlessly as a single static binary, and manage it using expressive, declarative configurations written in real programming languages. Once set up, Gofer takes care of scheduling and running your automation tasks—be it on Nomad, Kubernetes, or even Local Docker.</p>
<p>Its primary function is to execute short-term jobs like code linting, build automation, testing, port scanning, ETL operations, or any task you can containerize and trigger based on events.</p>
<h2 id="features"><a class="header" href="#features">Features:</a></h2>
<ul>
<li><strong>Simple Deployment</strong>: Install Gofer effortlessly with a single static binary and manage it through its intuitive command-line interface.</li>
<li><strong>Language Flexibility</strong>: Craft your pipelines in programming languages you're already comfortable with, such as Go or Rust—no more wrestling with unfamiliar YAML.</li>
<li><strong>Local Testing</strong>: Validate and run your pipelines locally, eliminating the guesswork of "commit and see" testing.</li>
<li><strong>Extensible Architecture</strong>: Easily extend Gofer's capabilities by writing your own plugins, backends, and more, in any language via OpenAPI.</li>
<li><strong>Built-In Storage</strong>: Comes with an integrated Object and Secret store for your convenience.</li>
<li><strong>DAG Support</strong>: Harness the power of Directed Acyclic Graphs (DAGs) for complex workflow automation.</li>
<li><strong>Robust Reliability</strong>: Automatic versioning, Blue/Green deployments, and canary releases ensure the stability and dependability of your pipelines.</li>
</ul>
<h2 id="demo"><a class="header" href="#demo">Demo:</a></h2>
<img src="https://clintjedwards.com/gofer/assets/demo.gif" />
<h2 id="documentation--getting-started"><a class="header" href="#documentation--getting-started">Documentation &amp; Getting Started</a></h2>
<p>If you want to fully dive into Gofer, check out the <a href="https://clintjedwards.github.io/gofer">documentation site</a>!</p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>Extended installation information is available through the <a href="https://clintjedwards.com/gofer/guide/installing_gofer.html">documentation site</a>.</p>
<h3 id="download-a-specific-release"><a class="header" href="#download-a-specific-release">Download a specific release:</a></h3>
<p>You can <a href="https://github.com/clintjedwards/gofer/releases">view and download releases by version here</a>.</p>
<h3 id="download-the-latest-release"><a class="header" href="#download-the-latest-release">Download the latest release:</a></h3>
<ul>
<li><strong>Linux:</strong> <code>wget https://github.com/clintjedwards/gofer/releases/latest/download/gofer</code></li>
</ul>
<h3 id="build-from-source"><a class="header" href="#build-from-source">Build from source:</a></h3>
<ol>
<li><code>git clone https://github.com/clintjedwards/gofer &amp;&amp; cd gofer</code></li>
<li><code>make build</code></li>
<li><code>ls ./target/release/gofer</code></li>
</ol>
<p>The Gofer binary comes with a CLI to manage the server as well as act as a client.</p>
<h2 id="dev-setup"><a class="header" href="#dev-setup">Dev Setup</a></h2>
<p>Gofer is setup such that the base run mode is the development mode. So simply running the binary
without any additional flags allows easy auth-less development. You can read more about how to deploy Gofer in a
production environment <a href="https://clintjedwards.com/gofer/ref/server_configuration/index.html">here</a></p>
<h3 id="youll-need-to-install-the-following-first"><a class="header" href="#youll-need-to-install-the-following-first">You'll need to install the following first:</a></h3>
<p>To run Gofer dev mode:</p>
<ul>
<li><a href="https://www.docker.com/">Docker</a></li>
</ul>
<h3 id="run-from-the-makefile"><a class="header" href="#run-from-the-makefile">Run from the Makefile</a></h3>
<p>Gofer uses flags, env vars, and files to manage configuration (in order of most important). The Makefile already includes all the commands and flags you need to run in dev mode by simply running <code>make run</code>.</p>
<p>In case you want to run without the make file simply run:</p>
<pre><code class="language-bash">cd gofer
export GOFER_WEB_API__LOG_LEVEL=debug
cargo run --bin gofer -- service start
</code></pre>
<h3 id="editing-openapi-spec-files"><a class="header" href="#editing-openapi-spec-files">Editing OpenAPI spec files</a></h3>
<h4 id="where-are-the-openapi-spec-files"><a class="header" href="#where-are-the-openapi-spec-files">Where are the openapi spec files?</a></h4>
<p>Gofer uses OpenAPI to generate a REST API in which is uses both to communicate with extensions and the main web service.</p>
<ul>
<li>You can find the OpenAPI spec files located in <code>sdk/openapi.json</code> and <code>gofer/docs/src/assets/openapi.json</code>.</li>
<li>This means you can also access the API reference by going to <code>/docs/api_reference.html</code> in the main web service.</li>
</ul>
<h4 id="how-do-we-generate-new-spec-files"><a class="header" href="#how-do-we-generate-new-spec-files">How do we generate new spec files?</a></h4>
<p>Gofer uses <a href="https://github.com/deepmap/oapi-codegen">oapi-codegen</a> to generate the Golang sdk and <a href="https://github.com/oxidecomputer/progenitor">progenitor</a> to generate the Rust SDK.</p>
<p>You can download oapi-codegen by performing <code>go install github.com/deepmap/oapi-codegen/v2/cmd/oapi-codegen@latest</code>.
Progenitor is already included as a lib within the generation code.</p>
<p>The OpenAPI Spec files are generated by the web framework used <a href="https://github.com/oxidecomputer/">dropshot</a>. It
generates the files directly from the code.</p>
<p>You can run the generate script by using <code>make generate-openapi</code> from the root directory.</p>
<h3 id="editing-documentation"><a class="header" href="#editing-documentation">Editing Documentation</a></h3>
<p>Documentation is done with <a href="https://rust-lang.github.io/mdBook/">mdbook</a>.</p>
<p>To install:</p>
<pre><code class="language-bash">cargo install mdbook
cargo install mdbook-linkcheck
</code></pre>
<p>Once you have mdbook you can simply run <code>make run-docs</code> to give you an auto-reloading dev version of the documentation
in a browser.</p>
<h3 id="regenerating-demo-gif"><a class="header" href="#regenerating-demo-gif">Regenerating Demo Gif</a></h3>
<p>The Gif on the README page uses <a href="https://github.com/charmbracelet/vhs">vhs</a>; a very handy tool that allows you to write a configuration file which will pop out
a gif on the other side.</p>
<p>In order to do this VHS has to run the commands so we must start the server first before we regenerate the gif.</p>
<pre><code class="language-bash">rm -rf /tmp/gofer* # Start with a fresh database
make run # Start the server in dev mode
cd documentation/src/assets
vhs &lt; demo.tape # this will start running commands against the server and output the gif as demo.gif.
</code></pre>
<h2 id="authors"><a class="header" href="#authors">Authors</a></h2>
<ul>
<li><strong>Clint Edwards</strong> - <a href="https://github.com/clintjedwards">Github</a></li>
</ul>
<p>This software is provided as-is. It's a hobby project, done in my free time, and I don't get paid for doing it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-does-gofer-work"><a class="header" href="#how-does-gofer-work">How does Gofer work?</a></h1>
<p>Gofer works in a very simple client-server model. You deploy Gofer as a single binary to your favorite VPS and you can configure it to connect to all the tooling you currently use to run containers.</p>
<p>Gofer acts as a scheduling middle man between a user's intent to run a container at the behest of an event and your already established container orchestration system.</p>
<h2 id="workflow"><a class="header" href="#workflow">Workflow</a></h2>
<p>Interaction with Gofer is mostly done through its <a href="./cli/index.html">command line interface</a> which is included in the same binary as the master service.</p>
<h3 id="general-workflow"><a class="header" href="#general-workflow">General Workflow</a></h3>
<ol>
<li>Gofer is connected to a container orchestrator of some sort. This can be just your local docker service or something like K8s or Nomad.</li>
<li>It launches it's configured extensions (extensions are just containers) and these extensions wait for events to happen or perform some service on behalf of your pipeline.</li>
<li>Users create pipelines (by configuration file) that define exactly in which order and what containers they would like to run.</li>
<li>These pipelines don't have to, but usually involve extensions so that pipelines can run automatically.</li>
<li>Either by extension or manual intervention a pipeline run will start and schedule the containers defined in the configuration file.</li>
<li>Gofer will collect the logs, exit code, and other essentials from each container run and provide them back to the user along with summaries of how that particular run performed.</li>
</ol>
<h2 id="extension-implementation"><a class="header" href="#extension-implementation">Extension Implementation</a></h2>
<ol>
<li>When Gofer launches the first thing it does is create the extension containers the same way it schedules any other container.</li>
<li>The extension containers are all small REST API web services that are implemented using a specific interface provided by the sdk.</li>
<li>Gofer passes the extension a secret value that only it knows so that the extension doesn't respond to any requests that might come from other sources.</li>
<li>After the extension is initialized Gofer will subscribe any pipelines that have requested this extension (through their pipeline configuration file) to that extension.</li>
<li>The extension then takes note of this subscription and waits for the relevant event to happen.</li>
<li>When the event happens it figures out which pipeline should be alerted and sends an event to the main Gofer process.</li>
<li>The main gofer process then starts a pipeline run on behalf of the extension.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<ul>
<li>
<p><strong>Pipeline:</strong> A pipeline is a collection of tasks that can be run at once. Pipelines can be defined via a <a href="./guide/create_your_first_pipeline_configuration.html">pipeline configuration file</a>. Once you have a pipeline config file you can <a href="./guide/register_your_pipeline.html">create a new pipeline via the CLI</a> (recommended) or API.</p>
</li>
<li>
<p><strong>Run:</strong> A run is a single execution of a pipeline. A run can be started automatically via <a href="./ref/extensions/index.html">extensions</a> or manually via the API or <a href="./cli/index.html">CLI</a></p>
</li>
<li>
<p><strong>Extension:</strong> A extension allow for the extension of pipeline functionality. Extension start-up with Gofer as long running containers and
pipelines can subscribe to them to have additional functionality.</p>
</li>
<li>
<p><strong>Task:</strong> A task is the lowest unit in Gofer. It is a small abstraction over running a single container. Through tasks you can define what container you want to run, when to run it in relation to other containers, and what variables/secrets those containers should use.</p>
</li>
<li>
<p><strong>Task Execution:</strong> A task execution is the programmatic running of a single task container. Referencing a specific task execution is how you can examine the results, logs, and details of one of your tasks on any given run.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h3 id="i-have-a-job-that-works-with-a-remote-git-repository-other-cicd-tools-make-this-trivial-how-do-i-mimic-that"><a class="header" href="#i-have-a-job-that-works-with-a-remote-git-repository-other-cicd-tools-make-this-trivial-how-do-i-mimic-that">&gt; I have a job that works with a remote git repository, other CI/CD tools make this trivial, how do I mimic that?</a></h3>
<p>The drawback of this model and architecture is does not specifically cater to GitOps. So certain workflows
that come out of the box from other CI/CD tooling will need to be recreated, due to its inherently distributed nature.</p>
<p>Gofer has provided several tooling options to help with this.</p>
<p>There are two problems that need to be solved around the managing of git repositories for a pipeline:</p>
<h4 id="1-how-do-i-authenticate-to-my-source-control-repository"><a class="header" href="#1-how-do-i-authenticate-to-my-source-control-repository">1) How do I authenticate to my source control repository?</a></h4>
<p>Good security practice suggests that you should be managing repository deploy keys, per repository, per team. You can
potentially forgo the "per team" suggestion using a "read-only" key and the scope of things using the key
isn't too big.</p>
<p>Gofer's suggestion here is to make deploy keys self service and then simply enter them into Gofer's secret store to be used by your pipeline's tasks. Once there you can then use it in each job to pull the required repository.</p>
<h4 id="2-how-do-i-download-the-repository"><a class="header" href="#2-how-do-i-download-the-repository">2) How do I download the repository?</a></h4>
<p>Three strategies:</p>
<ol>
<li>Just download it when you need it. Depending on the size of your repository and the frequency of the pull, this can work absolutely fine.</li>
<li>Use the object store as a cache. Gofer provides an object store to act as a permanent (pipeline-level) or short-lived
(run-level) cache for your workloads. Simply store the repository inside the object store and pull down per job
as needed.</li>
<li>Download it as you need it using a local caching git server. Once your repository starts becoming large or you do many
pulls quickly it might make more sense to use a cache<sup class="footnote-reference"><a href="#1">1</a></sup>,<sup class="footnote-reference"><a href="#2">2</a></sup>. It also makes sense to only download what you
need using git tools like <code>sparse checkout</code></li>
</ol>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>https://github.com/google/goblet</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>https://github.com/jonasmalacofilho/git-cache-http-server</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-guide"><a class="header" href="#feature-guide">Feature Guide</a></h1>
<h2 id="write-your-pipelines-in-a-real-programming-language"><a class="header" href="#write-your-pipelines-in-a-real-programming-language">Write your pipelines in a real programming language.</a></h2>
<p>Other infrastructure tooling tried configuration languages(yaml, hcl).... and they kinda suck<sup class="footnote-reference"><a href="#1">1</a></sup>. The Gofer CLI allows you to create your pipelines in a fully featured programming language. Pipelines can be currently be written in Go or Rust<sup class="footnote-reference"><a href="#2">2</a></sup>.</p>
<h2 id="dagdirected-acyclic-graph-support"><a class="header" href="#dagdirected-acyclic-graph-support">DAG(Directed Acyclic Graph) Support.</a></h2>
<p>Gofer provides the ability to run your containers in reference to your other containers.</p>
<p>With DAG support you can run containers:</p>
<ul>
<li>In parallel.</li>
<li>After other containers.</li>
<li>When particular containers fail.</li>
<li>When particular containers succeed.</li>
</ul>
<h2 id="openapi-compatible"><a class="header" href="#openapi-compatible">OpenAPI compatible</a></h2>
<p>Gofer uses <a href="https://www.openapis.org/">OpenAPI</a> to construct its API surface. This means that Gofer's API is easy to use,
well defined, and can easily be developed for in any language.</p>
<p>The use of OpenAPI gives us two main advantages:</p>
<ol>
<li>The most up-to-date API contract can always be found by reading <a href="https://github.com/clintjedwards/gofer/blob/main/gofer/docs/src/assets/openapi.json">the openapi spec files</a> included in the source.</li>
<li>Developing against the API for developers working within Golang/Rust simply means importing the provided sdk.</li>
<li>Developing against the API for developers not working within the Go/Rust language means simply generating an sdk using your <a href="https://openapi.tools/">language specific tooling</a></li>
</ol>
<h2 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h2>
<p>Gofer allows you to separate out your pipelines into different namespaces, allowing you to organize your teams and set permissions based on those namespaces.</p>
<h2 id="extensions"><a class="header" href="#extensions">Extensions</a></h2>
<p>Extensions are the way users can add extra functionality to their pipelines. For instance the ability to automate their pipelines by waiting on bespoke events (like the passage of time).</p>
<p>Extensions are nothing more than containers themselves that talk to the main process when they require activity.</p>
<p>Gofer out of the box provides some default extensions like <a href="./ref/extensions/provided/cron.html">cron</a> and <a href="./ref/extensions/provided/interval.html">interval</a>. But even more powerful than that, it accepts any type of extension you can think up and code using the included extension sdk.</p>
<p>You can view how extensions work by visiting the sample extension <a href="https://github.com/clintjedwards/gofer/blob/main/containers/extensions/interval">'interval'</a></p>
<p>Extensions are brought up alongside Gofer as long-running containers that it launches and manages.</p>
<h2 id="object-store"><a class="header" href="#object-store">Object Store</a></h2>
<p>Gofer provides a built in <a href="./ref/object_store/index.html">object store</a> you can access with the Gofer CLI. This object store provides a caching and data transfer mechanism so you can pass values from one container to the next, but also store objects that you might need for all containers.</p>
<h2 id="secret-store"><a class="header" href="#secret-store">Secret Store</a></h2>
<p>Gofer provides a built in <a href="./ref/secret_store/index.html">secret store</a> you can access with the Gofer CLI. This secret store provides a way to pass secret values needed by your pipeline configuration into Gofer.</p>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>Gofer provides a list of events for the most common actions performed. You can view this event stream via the Gofer API, allowing you to build on top of Gofer's actions and even using Gofer as a trigger for other events.</p>
<h2 id="external-events"><a class="header" href="#external-events">External Events</a></h2>
<p>Gofer allows extensions to consume external events. This allows for extensions to respond to webhooks from favorite sites like Github and more.</p>
<h2 id="pluggable-everything"><a class="header" href="#pluggable-everything">Pluggable Everything</a></h2>
<p>Gofer plugs into all your favorite backends your team is already using. This means that you never have to maintain things outside of your wheelhouse.</p>
<p>Whether you want to schedule your containers on <a href="https://kubernetes.io/">K8s</a> or <a href="https://aws.amazon.com/lambda/">AWS Lambda</a>, or maybe you'd like to use an object store that you're more familiar with in <a href="https://min.io/">minio</a> or <a href="https://aws.amazon.com/s3/">AWS S3</a>, Gofer provides either an already created plugin or an interface to write your own.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Initially why configuration languages are used made sense, namely lowering the bar for users who might not know how to program and making it simpler overall to maintain(read: not shoot yourself in the foot with crazy inheritance structures). But, in practice, we've found that they kinda suck. Nobody wants to learn yet another language for this one specific thing. Furthermore, using a separate configuration language doesn't allow you to plug into years of practice/tooling/testing teams have with a certain favorite language.</p>
</div>
<!-- prettier-ignore -->
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>All pipelines eventually reduce to json, so given the correct libraries your pipelines can be written in any language you like!</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h1>
<p>In order to schedule workloads on Gofer your code will need to be wrapped in a docker container. This is a short workflow blurb about how to create containers to best work with Gofer.</p>
<h2 id="1-write-your-code-to-be-idempotent"><a class="header" href="#1-write-your-code-to-be-idempotent">1) Write your code to be idempotent.</a></h2>
<p>Write your code in whatever language you want, but it's a good idea to make it idempotent. Gofer does not guarantee single container runs (but even if it did that doesn't prevent mistakes from users).</p>
<h2 id="2-follow-12-factor-best-practices"><a class="header" href="#2-follow-12-factor-best-practices">2) Follow <a href="https://12factor.net">12-factor best practices.</a></a></h2>
<p><a href="https://12factor.net/config">Configuration</a> is the important one. Gofer manages information into containers by environment variables so your code will need to take any input or configuration it needs from environment variables.</p>
<h2 id="3-keep-things-simple"><a class="header" href="#3-keep-things-simple">3) Keep things simple.</a></h2>
<p>You could, in theory, create a super complicated graph of containers that run off each other. But the main theme of Gofer is simplicity. Make sure you're thinking through the benefits of managing something in separate containers vs just running a monolith container. There are good reasons for both; always err on the side of clarity and ease of understanding.</p>
<h2 id="4-keep-your-containers-lean"><a class="header" href="#4-keep-your-containers-lean">4) Keep your containers lean.</a></h2>
<p>Because of the potentially distributed nature of Gofer, the larger the containers you run, the greater potential lag time between the start of execution for your container. This is because there is no guarantee that your container will end up on a machine that already has the image. Downloading large images takes a lot of time and a lot of disk space.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-gofer"><a class="header" href="#troubleshooting-gofer">Troubleshooting Gofer</a></h1>
<p>This page provides various tips on how to troubleshoot and find issues/errors within Gofer.</p>
<h2 id="debugging-extensions"><a class="header" href="#debugging-extensions">Debugging extensions</a></h2>
<p>Extensions are simply long running containers that internally wait for an event to happen and then communicate with Gofer it's API.</p>
<p>There are two main avenues to debug extensions:</p>
<ul>
<li><code>gofer extension logs &lt;id&gt;</code> will stream an extension's logs.</li>
<li>Each extension has a <code>/api/debug</code> endpoint that dumps debug information about that extension.</li>
</ul>
<h2 id="debugging-tasks"><a class="header" href="#debugging-tasks">Debugging Tasks</a></h2>
<p>When tasks aren't working quite right, it helps to have some simple tasks that you can use to debug. Gofer provides a few of these to aid in debugging.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Image</th><th>Description</th></tr></thead><tbody>
<tr><td>envs</td><td>ghcr.io/clintjedwards/gofer/debug/envs</td><td>Simply prints out all environment variables found</td></tr>
<tr><td>fail</td><td>ghcr.io/clintjedwards/gofer/debug/fail</td><td>Purposely exist with a non-zero exit code. Useful for testing that pipeline failures or alerting works correctly.</td></tr>
<tr><td>log</td><td>ghcr.io/clintjedwards/gofer/debug/log</td><td>Prints a couple paragraphs of log lines with 1 second in-between, useful as a container that takes a while to finish and testing that log following is working correctly</td></tr>
<tr><td>wait</td><td>ghcr.io/clintjedwards/gofer/debug/wait</td><td>Wait a specified amount of time and then successfully exits.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="gofers-philosophy"><a class="header" href="#gofers-philosophy">Gofer's Philosophy</a></h1>
<h2 id="short-version"><a class="header" href="#short-version">Short version</a></h2>
<p>Gofer focuses on the usage of containers to run workloads that don't belong as long-running applications. At it's core,
it is a remote code execution platform. The ability to run containers <em>easily</em> is powerful tool for users who need to
run various short-term workloads and don't want to learn a whole new paradigm to do it. Gofer respects the user by
inviting them to follow a golden path for how to do things, but also giving them the power to leave it when necessary.</p>
<p>Gofer's core values are:</p>
<ul>
<li>Simple as possible, but no simpler.</li>
<li>Easy to use. Don't get in the way of the user.</li>
<li>Fast. Computers wait on people not the other way around.</li>
</ul>
<h2 id="long-version"><a class="header" href="#long-version">Long version</a></h2>
<p>If you'd like to read more about why Gofer exists and the journey in creating it, you can do so here: // TODO():</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Let's start by setting up our first Gofer pipeline!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-gofer"><a class="header" href="#installing-gofer">Installing Gofer</a></h1>
<p>Gofer comes as an easy to distribute pre-compiled binary that you can run on your machine locally, but you can always build Gofer from <a href="guide/installing_gofer.html#from-source">source</a> if need be.</p>
<h2 id="pre-compiled-recommended"><a class="header" href="#pre-compiled-recommended">Pre-compiled (Recommended)</a></h2>
<p>You can download the latest version for linux here:</p>
<pre><code class="language-bash">wget https://github.com/clintjedwards/gofer/releases/latest/download/gofer
</code></pre>
<h2 id="from-source"><a class="header" href="#from-source">From Source</a></h2>
<pre><code class="language-bash">cd gofer
cargo build --release
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-the-server-locally"><a class="header" href="#running-the-server-locally">Running the Server Locally</a></h1>
<p>Gofer is deployed as a single static binary allowing you to run the full service locally so you can play with the
internals before committing resources to it. Spinning Gofer up locally is also a great way to
debug "what would happen if?" questions that might come up during the creation of pipeline config files.</p>
<h2 id="install-gofer"><a class="header" href="#install-gofer"><a href="guide/./installing_gofer.html">Install Gofer</a></a></h2>
<h2 id="install-docker"><a class="header" href="#install-docker">Install Docker</a></h2>
<p>The way in which Gofer runs containers is called a <a href="guide/../ref/scheduler/index.html">Scheduler</a>. When deploying Gofer at
scale we can deploy it with a more serious container scheduler (<a href="https://www.nomadproject.io/">Nomad</a>,
<a href="https://kubernetes.io/">Kubernetes</a>) but for now we're just going to use the default local docker scheduler included.
This simply uses your local instance of <a href="guide/../ref/scheduler/docker.html">docker</a> instance to run containers.</p>
<p>But before we use your local docker service... you have to have one in the first place. If you don't have docker
installed, the installation is quick. Rather than covering the specifics here you can instead find a guide on how to
install docker for your operating system <a href="https://docs.docker.com/get-docker/">on its documentation site.</a></p>
<h2 id="start-the-server"><a class="header" href="#start-the-server">Start the server</a></h2>
<p>By default the Gofer binary is able to run the server in development mode. Simply start the service by:</p>
<pre><code class="language-bash">gofer service start
</code></pre>
<div class="box note">
    <div class="text"><strong>Note:</strong> The Gofer CLI has many useful commands, try running `gofer -h` to see a full listing.</div>
</div>
<style>
.box {
    padding: 10px 15px;
    margin: 10px 0;
    align-items: center;
}

.note {
    border-left: 5px solid #0074d9;
}
</style>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-your-first-pipeline-configuration"><a class="header" href="#create-your-first-pipeline-configuration">Create Your First Pipeline Configuration</a></h1>
<p>Before you can start running containers you must tell Gofer what you want to run. To do this we create what is called
a <code>pipeline configuration</code>.</p>
<p>The creation of this pipeline configuration is very easy and can be done in either Golang or Rust. This allows you to
use a fully-featured programming language to organize your pipelines, instead of dealing with YAML mess.</p>
<h2 id="lets-go"><a class="header" href="#lets-go">Let's Go!</a></h2>
<p>As an example, let's just copy a pipeline that has been given to us already. We'll use Go as our language, which
means you'll need to <a href="https://go.dev/doc/install">install it</a> if you don't have it. The Gofer repository gives
us a <a href="https://github.com/clintjedwards/gofer/tree/main/examplePipelines/go/simple">simple pipeline</a> that we can
copy and use.</p>
<h3 id="lets-first-create-a-folder-where-well-put-our-pipeline"><a class="header" href="#lets-first-create-a-folder-where-well-put-our-pipeline">Let's first create a folder where we'll put our pipeline:</a></h3>
<pre><code class="language-bash">mkdir /tmp/simple_pipeline
</code></pre>
<h3 id="then-lets-copy-the-gofer-provided-pipelines-main-file-into-the-correct-place"><a class="header" href="#then-lets-copy-the-gofer-provided-pipelines-main-file-into-the-correct-place">Then let's copy the Gofer provided pipeline's main file into the correct place:</a></h3>
<pre><code class="language-bash">cd /tmp/simple_pipeline
wget https://raw.githubusercontent.com/clintjedwards/gofer/main/examplePipelines/go/simple/main.go
</code></pre>
<p>This should create a <code>main.go</code> file inside our <code>/tmp/simple_pipeline</code> directory.</p>
<h3 id="lastly-lets-initialize-the-new-golang-program"><a class="header" href="#lastly-lets-initialize-the-new-golang-program">Lastly, let's initialize the new Golang program:</a></h3>
<p>To complete our Go program we simply have to initialize it with the <code>go mod</code> command.</p>
<pre><code class="language-bash">go mod init test/simple_pipeline
go mod tidy
</code></pre>
<p>The pipeline we generated above gives you a very simple pipeline with a few pre-prepared testing containers. You
should be able to view it using your favorite IDE.</p>
<p>The configuration itself is very simple. Essentially a pipeline contains of a few parts:</p>
<h4 id="some-basic-attributes-so-we-know-what-to-call-it-and-how-to-document-it"><a class="header" href="#some-basic-attributes-so-we-know-what-to-call-it-and-how-to-document-it">&gt; Some basic attributes so we know what to call it and how to document it.</a></h4>
<pre><code class="language-go">err := sdk.NewPipeline("simple", "Simple Pipeline").
		Description("This pipeline shows off a very simple Gofer pipeline that simply pulls in " +
...
</code></pre>
<h4 id="the-containers-we-want-to-run-are-defined-through-tasks"><a class="header" href="#the-containers-we-want-to-run-are-defined-through-tasks">&gt; The containers we want to run are defined through <a href="guide/../ref/pipeline_configuration/tasks.html">tasks</a>.</a></h4>
<pre><code class="language-go">...
sdk.NewTask("simple_task", "ubuntu:latest").
    Description("This task simply prints our hello-world message and exits!").
    Command("echo", "Hello from Gofer!").Variable("test", "sample"),
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="register-your-pipeline"><a class="header" href="#register-your-pipeline">Register your pipeline</a></h1>
<p>Now we will register your newly created pipeline configuration with Gofer!</p>
<h2 id="more-cli-to-the-rescue"><a class="header" href="#more-cli-to-the-rescue">More CLI to the rescue</a></h2>
<p>From your terminal, lets use the Gofer binary to run the following command, pointing Gofer at your newly created pipeline folder:</p>
<pre><code class="language-bash">gofer up ./tmp/simple_pipeline
</code></pre>
<h2 id="examine-created-pipeline"><a class="header" href="#examine-created-pipeline">Examine created pipeline</a></h2>
<p>It's that easy!</p>
<p>The Gofer command line application uses your local Golang compiler to compile, parse, and upload your pipeline configuration to Gofer.</p>
<p>You should have received a success message and some suggested commands:</p>
<pre><code class="language-bash"> ✓ Created pipeline: [simple] "Simple Pipeline"

  View details of your new pipeline: gofer pipeline get simple
  Start a new run: gofer run start simple
</code></pre>
<p>We can view the details of our new pipeline by running:</p>
<pre><code class="language-bash">gofer pipeline get simple
</code></pre>
<p>If you ever forget your pipeline ID you can list all pipelines that you own by using:</p>
<pre><code class="language-bash">gofer pipeline list
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="start-a-run"><a class="header" href="#start-a-run">Start a Run</a></h1>
<p>Now that we've set up Gofer, defined our pipeline, and registered it we're ready to actually run our containers.</p>
<h2 id="press-start"><a class="header" href="#press-start">Press start</a></h2>
<pre><code class="language-bash">gofer pipeline run simple
</code></pre>
<h2 id="what-happens-now"><a class="header" href="#what-happens-now">What happens now?</a></h2>
<p>When you start a run Gofer will attempt to schedule all your tasks according to their dependencies onto your chosen scheduler. In this case that scheduler is your local instance of Docker.</p>
<p>Your run should be chugging along now!</p>
<h4 id="view-a-list-of-runs-for-your-pipeline"><a class="header" href="#view-a-list-of-runs-for-your-pipeline">View a list of runs for your pipeline:</a></h4>
<pre><code class="language-bash">gofer run list simple
</code></pre>
<h4 id="view-details-about-your-run"><a class="header" href="#view-details-about-your-run">View details about your run:</a></h4>
<pre><code class="language-bash">gofer run get simple 1
</code></pre>
<h4 id="list-the-containers-that-executed-during-the-run"><a class="header" href="#list-the-containers-that-executed-during-the-run">List the containers that executed during the run:</a></h4>
<pre><code class="language-bash">gofer task list simple 1
</code></pre>
<h4 id="view-a-particular-containers-details-during-the-run"><a class="header" href="#view-a-particular-containers-details-during-the-run">View a particular container's details during the run:</a></h4>
<pre><code class="language-bash">gofer task get simple 1 &lt;task_id&gt;
</code></pre>
<h4 id="stream-a-particular-containers-logs-during-the-run"><a class="header" href="#stream-a-particular-containers-logs-during-the-run">Stream a particular container's logs during the run:</a></h4>
<pre><code class="language-bash">gofer task logs simple 1 &lt;task_id&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h1>
<p>Anything!</p>
<ol>
<li>Keep playing with Gofer locally and check out all the <a href="guide/../cli">CLI commands</a>.</li>
<li>Spruce up your <a href="guide/../ref/pipeline_configuration">pipeline definition</a>!</li>
<li>Learn more about Gofer <a href="guide/../glossary.html">terminology</a>.</li>
<li><a href="guide/../ref/server_configuration">Deploy Gofer for real</a>. Pair it with your favorite scheduler and start using it to automate your jobs.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipeline-configuration"><a class="header" href="#pipeline-configuration">Pipeline Configuration</a></h1>
<p>A pipeline is a directed acyclic graph of tasks that run together. A single execution of a pipeline is called a run.
Gofer allows users to configure their pipeline via a configuration file written in <a href="https://go.dev/">Golang</a> or
<a href="https://www.rust-lang.org/">Rust</a>.</p>
<p>The general hierarchy for a pipeline is:</p>
<pre><code>namespace
   \_ pipeline
         \_ run
             \_ task
</code></pre>
<p>That is to say:</p>
<ol>
<li>A namespace might contain multiple pipelines.</li>
<li>A pipeline is made up of tasks/containers to be run.</li>
<li>Every time a pipeline is executed it is done through the concept of a run which makes sure the containers are executed properly.</li>
</ol>
<h2 id="sdk"><a class="header" href="#sdk">SDK</a></h2>
<p>Creating a pipeline involves using the SDK currently written in Go or Rust.</p>
<h2 id="small-walkthrough"><a class="header" href="#small-walkthrough">Small Walkthrough</a></h2>
<p>To introduce some of the concepts slowly, lets build a pipeline step by step. We'll be using Go as our pipeline
configuration language and this documentation assumes you've already set up a new Go project and are operating
in a <code>main.go</code> file. If you haven't you can set up one
<a href="ref/pipeline_configuration/../../guide/create_your_first_pipeline_configuration.html">following the guide instructions.</a></p>
<h3 id="a-simple-pipeline"><a class="header" href="#a-simple-pipeline">A Simple Pipeline</a></h3>
<p>Every pipeline is initialized with a simple pipeline declaration. It's here that we will name our pipeline,
giving it a machine referable ID and a human referable name.</p>
<pre><code class="language-go">err := sdk.NewPipeline("simple", "My Simple Pipeline")
</code></pre>
<p>It's important to note here that while your human readable name ("My Simple Pipeline" in this case) can contain a large array of characters the ID can only container alphanumeric letters, numbers, and underscores. Any other characters will result in an error when attempting to register the pipeline.</p>
<h3 id="add-a-description"><a class="header" href="#add-a-description">Add a Description</a></h3>
<p>Next we'll add a simple description to remind us what this pipeline is used for.</p>
<pre><code class="language-go">err := sdk.NewPipeline("simple", "My Simple Pipeline").
        Description("This pipeline is purely for testing purposes.")
</code></pre>
<p>The SDK uses a builder pattern, which allows us to simply add another function onto our Pipeline object
which we can type our description into.</p>
<h3 id="add-a-task"><a class="header" href="#add-a-task">Add a task</a></h3>
<p>Lastly let's add a task(container) to our pipeline. We'll add a simple ubuntu container and change the command that gets
run on container start to just say "Hello from Gofer!".</p>
<pre><code class="language-go">err := sdk.NewPipeline("simple", "My Simple Pipeline").
        Description("This pipeline is purely for testing purposes.").
        Tasks(sdk.NewTask("simple_task", "ubuntu:latest").
			Description("This task simply prints our hello-world message and exists!").
			Command("echo", "Hello from Gofer!"),
    )
</code></pre>
<p>We used the <code>Tasks</code> function to add multiple tasks and then we use the SDK's <code>NewTask</code> function to create a task.
You can see we:</p>
<ul>
<li>Give the task an ID, much like our pipeline earlier.</li>
<li>Specify which image we want to use.</li>
<li>Tack on a description.</li>
<li>And then finally specify the command.</li>
</ul>
<p>To tie a bow on it, we add the <code>.Finish()</code> function to specify that our pipeline is in it's final form.</p>
<pre><code class="language-go">err := sdk.NewPipeline("my_pipeline", "My Simple Pipeline").
    Description("This pipeline is purely for testing purposes.").
    Tasks(sdk.NewTask("simple_task", "ubuntu:latest").
			Description("This task simply prints our hello-world message and exists!").
			Command("echo", "Hello from Gofer!"),
    ).Finish()
</code></pre>
<p>That's it! This is a fully functioning pipeline.</p>
<p>You can run and test this pipeline much like you would any other code you write. Running it will produce
a JSON output which Gofer uses to pass to the server.</p>
<p>You can find examples like this and more in <a href="https://github.com/clintjedwards/gofer/tree/main/examplePipelines">example pipelines</a></p>
<h2 id="extra-examples"><a class="header" href="#extra-examples">Extra Examples</a></h2>
<h3 id="auto-inject-api-tokens"><a class="header" href="#auto-inject-api-tokens">Auto Inject API Tokens</a></h3>
<p>Gofer has the ability to auto-create and inject a token into your tasks. This is helpful if you
want to use the <a href="ref/pipeline_configuration/../../cli/index.html">Gofer CLI</a> or the Gofer API to communicate with Gofer at
some point in your task.</p>
<p>You can tell Gofer to do this by using the <code>InjectAPIToken</code> function for a particular task.</p>
<p>The token will be cleaned up the same time the logs for a particular run is cleaned up.</p>
<pre><code class="language-go">err := sdk.NewPipeline("my_pipeline", "My Simple Pipeline").
    Description("This pipeline is purely for testing purposes.").
    Tasks(
		sdk.NewTask("simple_task", "ubuntu:latest").
			Description("This task simply prints our hello-world message and exists!").
			Command("echo", "Hello from Gofer!").InjectAPIToken(true),
    ).Finish()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tasks"><a class="header" href="#tasks">Tasks</a></h1>
<p>Gofer's abstraction for running a container is called a Task. Specifically Tasks are containers you point Gofer to and
configure to perform some workload.</p>
<p>A Task can be any container you want to run. In the
<a href="ref/pipeline_configuration/../../guide/create_your_first_pipeline_configuration.html">Getting Started</a> example we take a regular standard
<code>ubuntu:latest</code> container and customize it to run a passed in bash script.</p>
<pre><code class="language-go">Tasks(
    sdk.NewTask("simple_task", "ubuntu:latest").
        Description("This task simply prints our hello-world message and exists!").
        Command("echo", "Hello from Gofer!"),
)
</code></pre>
<h2 id="task-environment-variables-and-configuration"><a class="header" href="#task-environment-variables-and-configuration">Task Environment Variables and Configuration</a></h2>
<p>Gofer handles container configuration <a href="https://12factor.net/config">the cloud native way</a>. That is to say every
configuration is passed in as an environment variable. This allows for many advantages, the greatest of
which is standardization.</p>
<p>As a user, you pass your configuration in via the <code>Variable(s)</code> flavor of functions in your pipeline config.</p>
<p>When a container is run by Gofer, the Gofer scheduler has the potential to pass in configuration from multiple sources<sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<ol>
<li><strong>Your pipeline configuration:</strong> Configs you pass in by using the <code>Variable(s)</code> functions.</li>
<li><strong>Runtime Configurations:</strong> When a pipeline is run you can pass in variables that the pipeline should be run with.
This is also how extensions pass in variable configurations.</li>
<li><strong>Gofer's system configurations:</strong> Gofer will pass in system configurations that might be helpful to the user.
(For example, what current pipeline is running.)[^2]</li>
</ol>
<p>The exact key names injected for each of these configurations can be seen on any task by getting that task's details:
<code>gofer task get &lt;pipeline_name&gt; &lt;run_id&gt; &lt;task_id&gt;</code></p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>These sources are ordered from most to least important. Since the configuration is passed in a "Key =&gt; Value"
format any conflicts between sources will default to the source with the greater importance. For instance,
a pipeline config with the key <code>GOFER_PIPELINE_ID</code> will replace the key of the same name later injected by the
Gofer system itself.</p>
</div>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody>
<tr><td><code>GOFER_PIPELINE_ID</code></td><td>The pipeline identification string.</td></tr>
<tr><td><code>GOFER_RUN_ID</code></td><td>The run identification number.</td></tr>
<tr><td><code>GOFER_TASK_ID</code></td><td>The task execution identification string.</td></tr>
<tr><td><code>GOFER_TASK_IMAGE</code></td><td>The image name the task is currently running with.</td></tr>
<tr><td><code>GOFER_API_TOKEN</code></td><td>Optional. Runs can be assigned a unique Gofer API token automatically. This makes it easy and manageable for tasks to query Gofer's API and do lots of other convenience tasks.</td></tr>
</tbody></table>
</div>
<h2 id="what-happens-when-a-task-is-run"><a class="header" href="#what-happens-when-a-task-is-run">What happens when a task is run?</a></h2>
<p>The high level flow is:</p>
<ol>
<li>Gofer checks to make sure your task configuration is valid.</li>
<li>Gofer parses the task configuration's variables list. It attempts replace any substitution variables with their actual values from the object or secret store.</li>
<li>Gofer then passes the details of your task to the configured scheduler, variables are passed in as environment variables.</li>
<li>Usually this means the scheduler will take the configuration and attempt to pull the <code>image</code> mentioned in the configuration.</li>
<li>Once the image is successfully pulled the container is then run with the settings passed.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-configuration"><a class="header" href="#server-configuration">Server Configuration</a></h1>
<p>Gofer runs as a single static binary that you deploy onto your favorite VPS.</p>
<p>While Gofer will happily run in development mode without any additional configuration, this mode is <strong>NOT</strong>
recommended for production workloads and <strong>not intended to be secure.</strong></p>
<p>Instead Gofer allows you to edit it's startup configuration allowing you to configure it to run on your favorite
container orchestrator, object store, and/or secret backend.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>There are a few steps to setting up the Gofer service for production:</p>
<h3 id="1-configuration"><a class="header" href="#1-configuration">1) Configuration</a></h3>
<p>First you will need to properly configure the Gofer service.</p>
<p>Gofer accepts configuration through environment variables or a configuration file. If a configuration key
is set both in an environment variable and in a configuration file, the value of the environment variable's
value will be the final value.</p>
<p>You can view a list of environment variables Gofer takes by using the <code>gofer service start -h</code> command. It's
important to note that each environment variable starts with a prefix of <code>GOFER_WEB_</code>. So setting the <code>api.log_level</code>
configuration can be set as:</p>
<pre><code class="language-bash">export GOFER_WEB_API__LOG_LEVEL=debug
</code></pre>
<h4 id="configuration-file"><a class="header" href="#configuration-file">Configuration file</a></h4>
<p>The Gofer service configuration file is written in <a href="https://toml.io/en/">TOML</a>.</p>
<h5 id="load-order"><a class="header" href="#load-order">Load order</a></h5>
<p>The Gofer service looks for its configuration in one of several places (ordered by first searched):</p>
<ol>
<li>/etc/gofer/gofer_web.toml</li>
</ol>
<h4 id="bare-minimum-production-file"><a class="header" href="#bare-minimum-production-file">Bare minimum production file</a></h4>
<p>These are the bare minimum values you should populate for a production ready Gofer configuration.</p>
<p>The values below should be changed depending on your environment; leaving them as they currently are will lead to loss
of data on server restarts.</p>
<h3 id="2-running-the-binary"><a class="header" href="#2-running-the-binary">2) Running the binary</a></h3>
<p>You can find the most recent releases of Gofer on the <a href="https://github.com/clintjedwards/gofer/releases">github releases page.</a>.</p>
<p>Simply use whatever configuration management system you're most familiar with to place the binary on your chosen
VPS and manage it. You can find a quick and dirty <code>wget</code> command to pull the
latest version in the <a href="ref/server_configuration/../../guide/index.html">getting started documentation.</a></p>
<h3 id="3-first-steps"><a class="header" href="#3-first-steps">3) First steps</a></h3>
<p>You will notice upon service start that the Gofer CLI is unable to make any requests due to permissions.</p>
<p>You will first need to handle the problem of auth. Every request to Gofer must use an API key so Gofer can
appropriately direct requests.</p>
<p>More information about auth in general terms <a href="ref/server_configuration/./authentication.html">can be found here.</a></p>
<p>To create your root management token use the command: <code>gofer service tokens bootstrap</code></p>
<div class="box note">
  <div class="text">
  <strong>Note:</strong>
  <p>The token returned is a management token and as such has access to all routes within Gofer. It is advised that:</p>
    <ol>
      <li> You use this token only in admin situations and to generate other lesser permissioned tokens.</li>
      <li> Store this token somewhere safe. </li>
    </ol>
    </div>
</div>
<p>From here you can use your root token to provision extra, lower permissioned tokens for everyday use.</p>
<p>When communicating with Gofer through the CLI you can set the token to be automatically passed per request in
<a href="ref/server_configuration/../../cli/configuration.html">one of many ways.</a></p>
<style>
.box {
    padding: 10px 15px;
    margin: 10px 0;
    align-items: center;
}

.note {
    border-left: 5px solid #0074d9;
}
</style>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-reference"><a class="header" href="#configuration-reference">Configuration Reference</a></h1>
<h2 id="this-page-might-be-outdated"><a class="header" href="#this-page-might-be-outdated">This page might be outdated.</a></h2>
<p>Gofer has a variety of parameters that can be specified via environment variables or the configuration file.</p>
<p>To view a list of all possible environment variables simply type: <code>gofer service start -h</code>.</p>
<p>The most up to date config file values can be found by
<a href="https://github.com/clintjedwards/gofer/blob/main/gofer/src/scheduler/mod.rs">reading the code</a> or running the
command above, but a best effort key and description list is given below.</p>
<p>If examples of these values are needed you can find a sample file by using <code>gofer service init-config</code>.</p>
<h2 id="values"><a class="header" href="#values">Values</a></h2>
<h3 id="general"><a class="header" href="#general">General</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>default</th><th>description</th></tr></thead><tbody>
<tr><td>event_log_retention</td><td>string (duration)</td><td>4380h</td><td>Controls how long Gofer will hold onto events before discarding them. This is important factor in disk space and memory footprint. Example: Rough math on a 5,000 pipeline Gofer instance with a full 6 months of retention puts the memory and storage footprint at about 9GB.</td></tr>
<tr><td>event_prune_interval</td><td>string</td><td>3h</td><td>How often to check for old events and remove them from the database. Will only remove events older than the value in event_log_retention.</td></tr>
<tr><td>ignore_pipeline_run_events</td><td>boolean</td><td>false</td><td>Controls the ability for the Gofer service to execute jobs on startup. If this is set to false you can set it to true manually using the CLI command <code>gofer service toggle-event-ingress</code>.</td></tr>
<tr><td>log_level</td><td>string</td><td>debug</td><td>The logging level that is output. It is common to start with <code>info</code>.</td></tr>
<tr><td>run_parallelism_limit</td><td>int</td><td>N/A</td><td>The limit automatically imposed if the pipeline does not define a limit. 0 is unlimited.</td></tr>
<tr><td>task_execution_logs_dir</td><td>string</td><td>/tmp</td><td>The path of the directory to store task execution logs. Task execution logs are stored as a text file on the server.</td></tr>
<tr><td>task_execution_log_expiry</td><td>int</td><td>20</td><td>The total amount of runs before logs of the oldest run will be deleted.</td></tr>
<tr><td>task_execution_stop_timeout</td><td>string</td><td>5m</td><td>The amount of time Gofer will wait for a container to gracefully stop before sending it a SIGKILL.</td></tr>
<tr><td>external_events_api</td><td>block</td><td>N/A</td><td>The external events API controls webhook type interactions with extensions. HTTP requests go through the events endpoint and Gofer routes them to the proper extension for handling.</td></tr>
<tr><td>object_store</td><td>block</td><td>N/A</td><td>The settings for the Gofer object store. The object store assists Gofer with storing values between tasks since Gofer is by nature distributed. This helps jobs avoid having to download the same objects over and over or simply just allows tasks to share certain values.</td></tr>
<tr><td>secret_store</td><td>block</td><td>N/A</td><td>The settings for the Gofer secret store. The secret store allows users to securely populate their pipeline configuration with secrets that are used by their tasks, extension configuration, or scheduler.</td></tr>
<tr><td>scheduler</td><td>block</td><td>N/A</td><td>The settings for the container orchestrator that Gofer will use to schedule workloads.</td></tr>
<tr><td>server</td><td>block</td><td>N/A</td><td>Controls the settings for the Gofer API service properties.</td></tr>
<tr><td>extensions</td><td>block</td><td>N/A</td><td>Controls settings for Gofer's extension system. Extensions are different workflows for running pipelines usually based on some other event (like the passing of time).</td></tr>
</tbody></table>
</div>
<h3 id="development-block"><a class="header" href="#development-block">Development (block)</a></h3>
<p>Special feature flags to make development easier</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>default</th><th>description</th></tr></thead><tbody>
<tr><td>bypass_auth</td><td>boolean</td><td>false</td><td>Skip authentication for all routes.</td></tr>
<tr><td>default_encryption</td><td>boolean</td><td>false</td><td>Use default encryption key to avoid prompting for a unique one.</td></tr>
<tr><td>pretty_logging</td><td>boolean</td><td>false</td><td>Turn on human readable logging instead of JSON.</td></tr>
<tr><td>use_localhost_tls</td><td>boolean</td><td>false</td><td>Use embedded localhost certs instead of prompting the user to provide one.</td></tr>
</tbody></table>
</div>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<pre><code class="language-toml">pretty_logging = true     # Tells the logging package to use human readable output.
bypass_auth = true        # Turns off auth.
use_included_certs = true # Automatically loads localhost certs for development.
```                                                                                                   |

### External Events API (block)

The external events API controls webhook type interactions with extensions. HTTP requests go through the events
endpoint and Gofer routes them to the proper extension for handling.

| name   | type    | default        | description                                                                               |
| ------ | ------- | -------------- | ----------------------------------------------------------------------------------------- |
| enable | boolean | true           | Enable the events api. If this is turned off the events http service will not be started. |
| host   | string  | localhost:8081 | The address and port to bind the events service to.                                       |

#### Example

```toml
enable = true
bind_address = "0.0.0.0:8081"
use_tls = false
</code></pre>
<h3 id="object-store-block"><a class="header" href="#object-store-block">Object Store (block)</a></h3>
<p>The settings for the Gofer object store. The object store assists Gofer with storing values between tasks since Gofer is by nature distributed. This helps jobs avoid having to download the same objects over and over or simply just allows tasks to share certain values.</p>
<p>You can find <a href="ref/server_configuration/../object_store/index.html">more information on the object store block here.</a></p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>default</th><th>description</th></tr></thead><tbody>
<tr><td>engine</td><td>string</td><td>sqlite</td><td>The engine Gofer will use to store state. The accepted values here are "sqlite".</td></tr>
<tr><td>pipeline_object_limit</td><td>int</td><td>50</td><td>The limit to the amount of objects that can be stored at the pipeline level. Objects stored at the pipeline level are kept permanently, but once the object limit is reach the oldest object will be deleted.</td></tr>
<tr><td>run_object_expiry</td><td>int</td><td>50</td><td>Objects stored at the run level are unlimited in number, but only last for a certain number of runs. The number below controls how many runs until the run objects for the oldest run will be deleted. Ex. an object stored on run number #5 with an expiry of 2 will be deleted on run #7 regardless of run health.</td></tr>
</tbody></table>
</div>
<h4 id="sqlite-block"><a class="header" href="#sqlite-block">Sqlite (block)</a></h4>
<p>The sqlite store is a built-in, easy to use object store. It is meant for development and small deployments.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>default</th><th>description</th></tr></thead><tbody>
<tr><td>path</td><td>string</td><td>/tmp/gofer-object.db</td><td>The path of the file that sqlite will use. If this file does not exist Gofer will create it.</td></tr>
<tr><td>sqlite</td><td>block</td><td>N/A</td><td>The sqlite storage engine.</td></tr>
</tbody></table>
</div>
<pre><code class="language-toml">[object_store]
engine = "sqlite"
pipeline_object_limit = 50
run_object_expiry = 50

[object_store.sqlite]
path = "/tmp/gofer_objects.db"
</code></pre>
<h3 id="secret-store-block"><a class="header" href="#secret-store-block">Secret Store (block)</a></h3>
<p>The settings for the Gofer secret store. The secret store allows users to securely populate their pipeline configuration with secrets that are used by their tasks, extension configuration, or scheduler.</p>
<p>You can find <a href="ref/server_configuration/../secret_store/index.html">more information on the secret store block here.</a></p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>default</th><th>description</th></tr></thead><tbody>
<tr><td>engine</td><td>string</td><td>sqlite</td><td>The engine Gofer will use to store state. The accepted values here are "sqlite".</td></tr>
<tr><td>sqlite</td><td>block</td><td>N/A</td><td>The sqlite storage engine.</td></tr>
</tbody></table>
</div>
<h4 id="sqlite-block-1"><a class="header" href="#sqlite-block-1">Sqlite (block)</a></h4>
<p>The sqlite store is a built-in, easy to use object store. It is meant for development and small deployments.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>default</th><th>description</th></tr></thead><tbody>
<tr><td>path</td><td>string</td><td>/tmp/gofer-secret.db</td><td>The path of the file that sqlite will use. If this file does not exist Gofer will create it.</td></tr>
<tr><td>encryption_key</td><td>string</td><td>"changemechangemechangemechangeme"</td><td>Key used to encrypt keys to keep them safe. This encryption key is responsible for facilitating that. It MUST be 32 characters long and cannot be changed for any reason once it is set or else all data will be lost.</td></tr>
</tbody></table>
</div>
<pre><code class="language-toml">[secret_store]
engine = "sqlite"

[secret_store.sqlite]
path = "/tmp/gofer_secrets.db"
encryption_key = "changemechangemechangemechangeme"
</code></pre>
<h3 id="scheduler-block"><a class="header" href="#scheduler-block">Scheduler (block)</a></h3>
<p>The settings for the container orchestrator that Gofer will use to schedule workloads.</p>
<p>You can find <a href="ref/server_configuration/../scheduler/index.html">more information on the scheduler block here.</a></p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>default</th><th>description</th></tr></thead><tbody>
<tr><td>engine</td><td>string</td><td>sqlite</td><td>The engine Gofer will use as a container orchestrator. The accepted values here are "docker".</td></tr>
<tr><td>docker</td><td>block</td><td>N/A</td><td><a href="https://www.docker.com/why-docker">Docker</a> is the default container orchestrator and leverages the machine's local docker engine to schedule containers.</td></tr>
</tbody></table>
</div>
<h4 id="docker-block"><a class="header" href="#docker-block">Docker (block)</a></h4>
<p><a href="https://www.docker.com/why-docker">Docker</a> is the default container orchestrator and leverages the machine's local docker engine to schedule containers.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>default</th><th>description</th></tr></thead><tbody>
<tr><td>prune</td><td>boolean</td><td>false</td><td>Controls if the docker scheduler should periodically clean up old containers.</td></tr>
<tr><td>prune_interval</td><td>string</td><td>24h</td><td>Controls how often the prune container job should run.</td></tr>
</tbody></table>
</div>
<pre><code class="language-toml">[scheduler]
engine = "docker"

[scheduler.docker]
prune = true
prune_interval = 604800
timeout = 300           # Should be the same or more than the task_execution_stop_timeout
</code></pre>
<h3 id="server-block"><a class="header" href="#server-block">Server (block)</a></h3>
<p>Controls the settings for the Gofer service's server properties.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>default</th><th>description</th></tr></thead><tbody>
<tr><td>host</td><td>string</td><td>localhost:8080</td><td>The address and port for the service to bind to.</td></tr>
<tr><td>shutdown_timeout</td><td>string</td><td>15s</td><td>The time Gofer will wait for all connections to drain before exiting.</td></tr>
<tr><td>tls_cert_path</td><td>string</td><td><Required></td><td>The TLS certificate Gofer will use for the main service endpoint. This is required.</td></tr>
<tr><td>tls_key_path</td><td>string</td><td><Required></td><td>The TLS certificate key Gofer will use for the main service endpoint. This is required.</td></tr>
<tr><td>storage_path</td><td>string</td><td>/tmp/gofer.db</td><td>Where to put Gofer's sqlite database.</td></tr>
<tr><td>storage_results_limit</td><td>int</td><td>200</td><td>The amount of results Gofer's database is allowed to return on one query.</td></tr>
</tbody></table>
</div>
<pre><code class="language-toml">url = "http://localhost:8080"
bind_address = "0.0.0.0:8080"
extension_address = "172.17.0.1:8080"
shutdown_timeout = 15
storage_path = "/tmp/gofer.db"
storage_results_limit = 200
use_tls = false
</code></pre>
<h3 id="extensions-block"><a class="header" href="#extensions-block">Extensions (block)</a></h3>
<p>Controls settings for Gofer's extension system. Extensions are different workflows for running pipelines usually based on some other event (like the passing of time).</p>
<p>You can find <a href="ref/server_configuration/../extensions/index.html">more information on the extension block here.</a></p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>default</th><th>description</th></tr></thead><tbody>
<tr><td>install_base_extensions</td><td>boolean</td><td>true</td><td>Attempts to automatically install the <code>cron</code> and <code>interval</code> extensions on first startup.</td></tr>
<tr><td>stop_timeout</td><td>string</td><td>5m</td><td>The amount of time Gofer will wait until extension containers have stopped before sending a SIGKILL.</td></tr>
<tr><td>tls_cert_path</td><td>string</td><td><Required></td><td>The TLS certificate path Gofer will use for the extensions. This should be a certificate that the main Gofer service will be able to access.</td></tr>
<tr><td>tls_key_path</td><td>string</td><td><Required></td><td>The TLS certificate path key Gofer will use for the extensions. This should be a certificate that the main Gofer service will be able to access.</td></tr>
</tbody></table>
</div>
<pre><code class="language-toml">install_std_extensions = true
stop_timeout = 300            # 5 mins
use_tls = false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication"><a class="header" href="#authentication">Authentication</a></h1>
<p>Gofer's auth system is meant to be extremely lightweight and a stand-in for a more complex auth system.</p>
<h2 id="how-auth-works"><a class="header" href="#how-auth-works">How auth works</a></h2>
<p>Gofer uses API Tokens for authorization. You pass a given token in whenever talking to the API and Gofer will evaluate
internally what type of token you possess and for which namespaces does it possess access.</p>
<h3 id="management-tokens"><a class="header" href="#management-tokens">Management Tokens</a></h3>
<p>The first type of token is a management token. Management tokens essentially act as root tokens and have access to all routes.</p>
<p>It is important to be extremely careful about where your management tokens end up and how they are used.</p>
<p>Other than system administration, the main use of management tokens are the creation of new tokens.
You can explore token creation though <a href="ref/server_configuration/../../cli/index.html">the CLI.</a></p>
<p>It is advised that you use a single management token as the root token by which you create all user tokens.</p>
<h3 id="client-tokens"><a class="header" href="#client-tokens">Client Tokens</a></h3>
<p>The most common token type is a client token. The client token simply controls which namespaces a user might have access to.</p>
<p>During token creation you can choose one or multiple namespaces for the token to have access to.</p>
<h2 id="how-to-auth-via-the-api"><a class="header" href="#how-to-auth-via-the-api">How to auth via the API</a></h2>
<p>Gofer requires two headers in order to auth successfully.</p>
<ul>
<li><code>Authorization: Bearer &lt;token&gt;</code></li>
<li><code>gofer-api-version: v&lt;version_number&gt;</code></li>
</ul>
<h2 id="how-to-auth-via-the-cli"><a class="header" href="#how-to-auth-via-the-cli">How to auth via the CLI</a></h2>
<p>The Gofer CLI accepts <a href="ref/server_configuration/../../cli/configuration.html">many ways of setting a token once you have one.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-events-1"><a class="header" href="#external-events-1">External Events</a></h1>
<p>Gofer has an alternate endpoint specifically for external events streams<sup class="footnote-reference"><a href="#1">1</a></sup>. This endpoint takes in http requests
from the outside and passes them to the relevant extension.</p>
<p>You can find more about external event configuration in the
<a href="ref/server_configuration/../server_configuration/configuration_reference.html">configuration-values</a> reference.</p>
<pre><code class="language-toml">enable = true
bind_address = "0.0.0.0:8081"
use_tls = false
</code></pre>
<h2 id="it-works-like-this"><a class="header" href="#it-works-like-this">It works like this:</a></h2>
<ol>
<li>
<p>When the Gofer service is started it starts the external events service on a separate port per the
service configuration settings. It is also possible to just turn off this feature via the same configuration file.</p>
</li>
<li>
<p>External services can send Gofer http requests with payloads and headers specific to the extension they're
trying to communicate with. It's possible to target specific extensions by using the <code>/events</code> endpoint.</p>
<p><code>ex: https://mygofer.mydomain.com/events/github &lt;- #extension label</code></p>
</li>
<li>
<p>Gofer serializes and forwards the request to the relevant extension where it is validated for authenticity of
sender and then processed.</p>
</li>
<li>
<p>A extension may then handle this external event in any way it pleases. For example, the Github extension takes in
external events which are expected to be Github webhooks and starts a pipeline if the event type matches one the user wanted.</p>
</li>
</ol>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The reason for the alternate endpoint is due to the security concerns with sharing the same endpoint as the
main API service of the Gofer API. Since this endpoint is different you can now specifically set up security
groups such that it is only exposed to IP addresses that you trust without exposing those same address to
Gofer as a whole.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scheduler"><a class="header" href="#scheduler">Scheduler</a></h1>
<p>Gofer runs the containers you reference in the pipeline configuration via a container orchestrator referred to here as a "scheduler".</p>
<p>The vision of Gofer is for you to use whatever scheduler your team is most familiar with.</p>
<h2 id="supported-schedulers"><a class="header" href="#supported-schedulers">Supported Schedulers</a></h2>
<p>The only currently supported scheduler is <a href="ref/scheduler/../scheduler/docker.html">local docker</a>. This scheduler is used for small deployments
and development work.</p>
<h2 id="how-to-add-new-schedulers"><a class="header" href="#how-to-add-new-schedulers">How to add new Schedulers?</a></h2>
<p>Schedulers are pluggable, but for them to maintain good performance and simplicity the code that orchestrates them must
be added to the schedulers folder within Gofer(which means they have to be written in Rust).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-scheduler"><a class="header" href="#docker-scheduler">Docker <small>scheduler</small></a></h1>
<p>The docker scheduler uses the machine's local docker engine to run containers. This is great for small or development workloads and very simple to implement. Simply download docker and go!</p>
<pre><code class="language-toml">[scheduler]
engine = "docker"

[scheduler.docker]
prune = true
prune_interval = 604800
timeout = 300
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Docker needs to be installed and the Gofer process needs to have the required permissions to run containers upon it.</p>
<p>Other than that the docker scheduler just needs to know how to clean up after itself.</p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>prune</td><td>bool</td><td>true</td><td>Whether or not to periodically clean up containers that are no longer in use. If prune is not turned on eventually the disk of the host machine will fill up with different containers that have run over time.</td></tr>
<tr><td>prune_interval</td><td>int</td><td>604800</td><td>How often to run the prune job. Depending on how many containers you run per day this value could easily be set to monthly.</td></tr>
<tr><td>timeout</td><td>int</td><td>300</td><td>The timeout for the request to the docker service. Should be the same or more than the task_execution_stop_timeout</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="object-store-1"><a class="header" href="#object-store-1">Object Store</a></h1>
<p>Gofer provides an object store as a way to share values and objects between containers. It can also be used as a cache.
It is common for one container to run, generate an artifact or values, and then store that object in the object store
for the next container or next run. The object store can be accessed through the <a href="ref/object_store/../../cli/index.html">Gofer CLI</a> or
through the normal Gofer API.</p>
<p>Gofer divides the objects stored into two different lifetime groups:</p>
<h2 id="pipeline-level-objects"><a class="header" href="#pipeline-level-objects">Pipeline-level objects</a></h2>
<p>Gofer can store objects permanently for each pipeline. You can store objects at the pipeline-level by using the
gofer pipeline object store command:</p>
<pre><code class="language-bash">gofer pipeline object put my-pipeline my_key1=my_value5
gofer pipeline object get my-pipeline my_key1
</code></pre>
<p>The limitation to pipeline level objects is that they have a limit of the number of objects that can be stored
per-pipeline. Once that limit is reached the oldest object in the store will be removed for the newest object.</p>
<h2 id="run-level-objects"><a class="header" href="#run-level-objects">Run-level objects</a></h2>
<p>Gofer can also store objects on a per-run basis. Unlike the pipeline-level objects run-level do not have a limit to how
many can be stored, but instead have a limit of how long they last. Typically after a certain number of runs a object
stored at the run level will expire and that object will be deleted.</p>
<p>You can access the run-level store using the run level store CLI commands. Here is an example:</p>
<pre><code class="language-bash">gofer run object put simple_pipeline my_key=my_value
gofer run object get simple_pipeline my_key
</code></pre>
<h2 id="supported-object-stores"><a class="header" href="#supported-object-stores">Supported Object Stores</a></h2>
<p>The only currently supported object store is the sqlite object store. Reference the <a href="ref/object_store/../server_configuration/configuration_reference.html">configuration reference</a> for a full list of configuration settings and options.</p>
<h2 id="how-to-add-new-object-stores"><a class="header" href="#how-to-add-new-object-stores">How to add new Object Stores?</a></h2>
<p>Object stores are pluggable, but for them to maintain good performance and simplicity the code that orchestrates them must
be added to the object_store folder within Gofer(which means they have to be written in Rust).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sqlite-object-store"><a class="header" href="#sqlite-object-store">Sqlite <small>object store</small></a></h1>
<p>The sqlite object store is great for development and small deployments.</p>
<pre><code class="language-toml">[object_store]
engine = "sqlite"
pipeline_object_limit = 50
run_object_expiry = 50

[object_store.sqlite]
path = "/tmp/gofer_objects.db"
</code></pre>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>Sqlite needs to create a file on the local machine making the only parameter it accepts a path to the database file.</p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>path</td><td>string</td><td>/tmp/gofer-object.db</td><td>The path on disk to the sqlite db file</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="secret-store-1"><a class="header" href="#secret-store-1">Secret Store</a></h1>
<p>Gofer provides a secret store as a way to enable users to pass secrets into pipeline configuration
files.</p>
<p>The secrets included in the pipeline file use a special syntax so that Gofer understands when it is given a
secret value instead of a normal variable.</p>
<pre><code class="language-toml">[secret_store]
engine = "sqlite"
</code></pre>
<h2 id="supported-secret-stores"><a class="header" href="#supported-secret-stores">Supported Secret Stores</a></h2>
<p>The only currently supported secret store is the sqlite object store. Reference the
<a href="ref/secret_store/../server_configuration/configuration_reference.html">configuration reference</a> for a full list of configuration
settings and options.</p>
<h2 id="how-to-add-new-secret-stores"><a class="header" href="#how-to-add-new-secret-stores">How to add new Secret Stores?</a></h2>
<p>Secret stores are pluggable, but for them to maintain good performance and simplicity the code that orchestrates them must
be added to the secret_store folder within Gofer(which means they have to be written in Rust).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sqlite-secret-store"><a class="header" href="#sqlite-secret-store">Sqlite <small>secret store</small></a></h1>
<p>The sqlite object store is great for development and small deployments.</p>
<pre><code class="language-toml">[secret_store]
engine = "sqlite"

[secret_store.sqlite]
path = "/tmp/gofer_secrets.db"
encryption_key = "changemechangemechangemechangeme"
</code></pre>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>Sqlite needs to create a file on the local machine making the only parameter it accepts a path to the database file.</p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>path</td><td>string</td><td>/tmp/gofer-secret.db</td><td>The path on disk to the sqlite b file</td></tr>
<tr><td>encryption_key</td><td>string</td><td><required></td><td>32 character key required to encrypt secrets</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="extensions-1"><a class="header" href="#extensions-1">Extensions</a></h1>
<p>Extensions are Gofer's way of adding additional functionality to pipelines. You can subscribe your pipeline to an extension, allowing that extension to give your pipeline extra powers.</p>
<p>The most straight-forward example of this, is the interval extension. This extension allows your pipeline to run everytime some amount of time has passed. Let's say you have a pipeline that needs to run every 5 mins. You would subscribe your pipeline to the <a href="ref/extensions/./provided/interval.html">interval</a> extension using the gofer cli command <code>gofer extension sub internal every_5_seconds</code> set to an interval of <code>5m</code>.</p>
<p>On startup, Gofer launches the interval extension as a long-running container. When your pipeline subscribes to it. The interval extension starts a timer and when 5 minutes have passed the extension sends an API request to Gofer, causing Gofer to run your pipeline.</p>
<h2 id="gofer-provided-extensions"><a class="header" href="#gofer-provided-extensions">Gofer Provided Extensions</a></h2>
<p>You can <a href="ref/extensions/index.html#how-to-add-new-extensions">create</a> your own extensions, but Gofer provides some <a href="ref/extensions/./provided/index.html">provided extensions</a> for use.</p>
<h2 id="how-do-i-install-a-extension"><a class="header" href="#how-do-i-install-a-extension">How do I install a Extension?</a></h2>
<p>Extensions must first be installed by Gofer administrators before they can be used. They can be installed by the CLI. For more information on how to install a specific extension run:</p>
<pre><code class="language-bash">gofer extension install -h
</code></pre>
<h2 id="how-do-i-configure-a-extension"><a class="header" href="#how-do-i-configure-a-extension">How do I configure a Extension?</a></h2>
<p>Extensions allow for both system and pipeline configuration<sup class="footnote-reference"><a href="#1">1</a></sup>. Meaning they have both Global settings that apply to all pipelines
and Pipeline specific settings. This is what makes them so dynamically useful!</p>
<h3 id="pipeline-configuration-1"><a class="header" href="#pipeline-configuration-1">Pipeline Configuration</a></h3>
<p>Most Extensions allow for some pipeline specific configuration usually referred to as "Parameters" or "Pipeline configuration".</p>
<p>These variables are passed when the user subscribes their pipeline to the extension. Each extension defines what this might be
in it's documentation.</p>
<h3 id="system-configuration"><a class="header" href="#system-configuration">System Configuration</a></h3>
<p>Most extensions have system configurations which allow the administrator or system to inject some needed variables. These are defined when the Extension is installed.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>See a specific Extension's documentation for the exact variables accepted and where they belong.</p>
</div>
<h2 id="how-to-add-new-extensions-how-do-i-create-my-own"><a class="header" href="#how-to-add-new-extensions-how-do-i-create-my-own">How to add new Extensions/ How do I create my own?</a></h2>
<p>Just like tasks, extensions are simply containers! Making them easily testable and portable. To create a new extension you simply use the included <a href="https://pkg.go.dev/github.com/clintjedwards/gofer/sdk">Gofer SDK</a>.</p>
<p>The SDK provides an interface in which a well functioning GRPC service will be created from your concrete implementation.</p>
<p>//TODO()</p>
<!-- ```go
```

For an commented example of a simple extension you can follow to build your own, view the [interval extension](https://github.com/clintjedwards/gofer/tree/main/containers/extensions/interval):

```go
``` -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="provided-extensions"><a class="header" href="#provided-extensions">Provided Extensions</a></h1>
<p>Gofer provides some pre-written extensions for quick use:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>image</th><th>included by default</th><th>description</th></tr></thead><tbody>
<tr><td><a href="ref/extensions/provided/./interval.html">interval</a></td><td>ghcr.io/clintjedwards/gofer/extensions/interval:latest</td><td>yes</td><td>Interval triggers a run after a predetermined amount of time has passed.</td></tr>
<tr><td><a href="ref/extensions/provided/./cron.html">cron</a></td><td>ghcr.io/clintjedwards/gofer/extensions/cron:latest</td><td>yes</td><td>Cron is used for longer termed, more nuanced intervals. For instance, running a pipeline every year on Christmas.</td></tr>
<tr><td><a href="ref/extensions/provided/./github.html">github</a></td><td>ghcr.io/clintjedwards/gofer/extensions/github:latest</td><td>no</td><td>Allow your pipelines to run based on branch, tag, or release activity.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="cron-extension"><a class="header" href="#cron-extension">Cron <small>Extension</small></a></h1>
<p>Cron allows users to schedule pipeline runs on long term intervals and specific days.</p>
<p>It uses a stripped down version of the cron syntax to do so:</p>
<pre><code>Field           Allowed values  Allowed special characters

Minutes         0-59            * , -
Hours           0-23            * , -
Day of month    1-31            * , -
Month           1-12            * , -
Day of week     0-6             * , -
Year            1970-2100       * , -
</code></pre>
<hr />
<pre><code>┌───────────── minute (0 - 59)
│ ┌───────────── hour (0 - 23)
│ │ ┌───────────── day of the month (1 - 31)
│ │ │ ┌───────────── month (1 - 12)
│ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)
│ │ │ │ │ ┌───────────── Year (1970-2100)
│ │ │ │ │ │
│ │ │ │ │ │
│ │ │ │ │ │
* * * * * *
</code></pre>
<h2 id="pipeline-configuration-2"><a class="header" href="#pipeline-configuration-2">Pipeline Configuration</a></h2>
<ul>
<li><code>expression</code> <string>: Specifies the cron expression of the interval desired.</li>
</ul>
<h3 id="every-year-on-xmas"><a class="header" href="#every-year-on-xmas">Every year on Xmas</a></h3>
<pre><code class="language-bash">gofer pipeline subscribe simple cron yearly_on_xmas -s expression="0 1 25 12 * *"
</code></pre>
<h2 id="extension-configuration"><a class="header" href="#extension-configuration">Extension Configuration</a></h2>
<p>None</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interval-extension"><a class="header" href="#interval-extension">Interval <small>Extension</small></a></h1>
<p>Interval simply runs the subscribed pipeline at the given time interval continously.</p>
<h2 id="parameterspipeline-configuration"><a class="header" href="#parameterspipeline-configuration">Parameters/Pipeline Configuration</a></h2>
<ul>
<li><code>every</code> <string>: Specifies the time duration between events. Unless changed via the extension configuration, the minimum for this is 5 mins.</li>
</ul>
<pre><code class="language-bash">gofer pipeline subscribe simple interval every_five_mins -s every="5m"
</code></pre>
<h2 id="extension-configuration-1"><a class="header" href="#extension-configuration-1">Extension Configuration</a></h2>
<p>Extension configurations are set upon extension startup and cannot be changed afterwards without restarting said extension.</p>
<div class="table-wrapper"><table><thead><tr><th>EnvVar</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>MIN_DURATION</td><td>"5m"</td><td>The minimum duration users can set their pipelines to run</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="github-extension"><a class="header" href="#github-extension">Github <small><em>Extension</em></small></a></h1>
<p>The Github extension allows Gofer pipelines to be run on <a href="https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads">Github webhook events.</a> This makes it possible to write event driven
workloads that depend on an action happening on Github.</p>
<p>See the <a href="ref/extensions/provided/github.html#events">events section below</a> for all supported events and the environment variables they pass to each
pipeline.</p>
<p>:::info
Due to the nature of Github's API and webhooks, you'll need to first set up a new Github app to use with Gofer's Github extension.</p>
<p><em>Steps to accomplish this can be found in the <a href="ref/extensions/provided/github.html#additional-setup">additional steps section.</a></em>
:::</p>
<p>:::danger
The Github extension requires the <a href="ref/extensions/provided/../../server_configuration/external_events.html">external events feature</a> of Gofer in order to accept webhooks from Github's servers. This requires your application to take traffic from external, potentially unknown sources.</p>
<p>Visit the <a href="ref/extensions/provided/../../server_configuration/external_events.html">external events page</a> for more information on how to configure Gofer's external
events endpoint.</p>
<p>If Github is your only external extension, to increase security consider <a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/about-githubs-ip-addresses">limiting the IP addresses</a> that can access Gofer's external events endpoint.
:::</p>
<h2 id="pipeline-configuration-3"><a class="header" href="#pipeline-configuration-3">Pipeline Configuration</a></h2>
<ul>
<li><code>repository</code> <string>: The Github repository you would like to listen for events from. The format is in the form
<code>&lt;organization&gt;/&lt;repository&gt;</code>.</li>
</ul>
<h2 id="extension-configuration-2"><a class="header" href="#extension-configuration-2">Extension Configuration</a></h2>
<p>Extension configurations are set upon startup and cannot be changed afterwards.</p>
<p>The Github extension requires the setup and use of a <a href="https://docs.github.com/en/developers/apps/getting-started-with-apps/about-apps">new Github app</a>. You can <a href="ref/extensions/provided/github.html#additional-setup">view setup instructions below</a> which will walk you through how to retrieve the required env var variables.</p>
<div class="table-wrapper"><table><thead><tr><th>EnvVar</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>GOFER_EXTENSION_GITHUB_APPS_ID</td><td>Required</td><td>The Github app ID</td></tr>
<tr><td>GOFER_EXTENSION_GITHUB_APPS_INSTALLATION</td><td>Required</td><td>The Github installation ID. This can be found by viewing the webhook payload delivery. See a more details walkthrough on where to find this below.</td></tr>
<tr><td>GOFER_EXTENSION_GITHUB_APPS_KEY</td><td>Required</td><td>The base64'd private key of the Github app. This can be generated during Github app creation time.</td></tr>
<tr><td>GOFER_EXTENSION_GITHUB_APPS_WEBHOOK_SECRET</td><td>Required</td><td>The Github app webhook secret key. This should be a long, randomized character string. It will be used to verify that an event came from Github and not another source.</td></tr>
</tbody></table>
</div>
<pre><code class="language-hcl">extensions {
  registered_extensions "github" {
    image = "ghcr.io/clintjedwards/gofer/extension_github:latest"
    env_vars = {
      "GOFER_EXTENSION_GITHUB_APPS_ID": "112348",
      "GOFER_EXTENSION_GITHUB_APPS_INSTALLATION": "99560091",
      "GOFER_EXTENSION_GITHUB_APPS_KEY": &lt;&lt;EOT
TUtkUnhYY01LTUI1ejgzZU84MFhKQWhoNnBkaFlCQlg0NGl5awpUUTBuaENySGRVT2kvN3hVaHp6
eTgxb3d0RUdpdUFQakJIOVhpSlczQm9hazYrSTZKWjU2RC95YllPbkVSaTdFClIxVkRQeGdGa0lE
NHdUbmtHdU4vdFY1VzBuZ3Q1aW0yVG5OVGVqc0NnWUVBb0pBMlJXZ2ZaSDdobVo3VS82TFUKSi9a
WTBZYmNkOU80anpYdWRUTUo1TXVKcVEwY004bnZhb09tS1Q1ekRadnBla01sRDlaYmZ4Rlg2Mzh3
N2ZuZwp0N05lbGFZc3IxYUhFWi9Rd2pveFo2RXpEWUJSQ0M2SEFvQmJXZmdwc1FCMkhNV3lzb2ls
LUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo=
EOT
      "GOFER_EXTENSION_GITHUB_APPS_WEBHOOK_SECRET": "somereallylongstringofcharacters",
    }
  }
}
</code></pre>
<h3 id="additional-setup"><a class="header" href="#additional-setup">Additional setup</a></h3>
<p>Due to the nature of Github's API and webhooks, you'll need to first set up a new Github app to use with Gofer's Github extension.
Once this app has been set up, you'll have access to all the required environment variables that you'll need to pass into Gofer's server configuration.</p>
<p>Here is a quick and dirty walkthrough on the important parts of setting up the Github application.</p>
<h4 id="1-create-a-new-github-application"><a class="header" href="#1-create-a-new-github-application">1. Create a new Github application:</a></h4>
<p><a href="https://docs.github.com/en/developers/apps/building-github-apps/creating-a-github-app">Github's documentation</a> will be the most up to date and relevant so please see their walkthrough.</p>
<p>On the configuration page for the new Github application the following should be noted:</p>
<ul>
<li>
<p><strong>APP ID</strong>: Take note of the id; it will be used later for extension configuration.</p>
</li>
<li>
<p><strong>Webhook URL</strong>: Should be the address of your Gofer's external extension instance and pointing to the events/github endpoint:</p>
<p><code>ex: https://mygoferinstance.yourdomain.com/external/github</code></p>
</li>
<li>
<p><strong>Webhook Secret</strong>: Make this a secure, long, random string of characters and note it for future extension configuration.</p>
</li>
<li>
<p><strong>Private Keys</strong>: Generate a private key and store it somewhere safe. You'll need to base64 this key and insert it into the extension configuration.</p>
<p><code>base64 ~/Desktop/myorg-gofer.2022-01-24.private-key.pem</code></p>
</li>
</ul>
<h4 id="2-find-the-installation-id"><a class="header" href="#2-find-the-installation-id">2. Find the installation ID</a></h4>
<p>Once the Github application has been created, <a href="https://docs.github.com/en/developers/apps/managing-github-apps/installing-github-apps">install it.</a>
This will give you an opportunity to configure the permissions and scope of the Github application.
It is recommended that you give read-only permissions to any permissions that might include webhooks and read-write for <code>code-suite</code> and <code>code-runs</code>.</p>
<p>The installation ID is unfortunately hidden in an event that gets sent once the Github app has been created and installed. You can find it by navigating to the settings page for the Github application and
then viewing it in the "Recent Deliveries" page.</p>
<blockquote>
<p>🪧 These recent deliveries only last a short amount of time, so if you take a while to check on them, they might not exist anymore. If that has happened you should be able to create another event and that will create another recent delivery.</p>
</blockquote>
<p><img src="ref/extensions/provided/../../../assets/github-apps-recent-deliveries.png" alt="Recent Deliveries" />
<img src="ref/extensions/provided/../../../assets/github-apps-installation-id.png" alt="Installation webhook event" /></p>
<h2 id="events-1"><a class="header" href="#events-1">Events</a></h2>
<p>Gofer's extensions have the ability to pass along event specific information in the form of environment variables that
get injected into each container's run. Most of these variables are pulled from the webhook request that comes in.</p>
<p>Below is a breakdown of the environment variables that are passed to a run based on the event that was generated.
You can find more information about the format the variables will be in by <a href="https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads">referencing the payloads for the event</a>.</p>
<p>Events below are the only events that are supported.</p>
<div class="table-wrapper"><table><thead><tr><th>Event</th><th>Metadata</th></tr></thead><tbody>
<tr><td>create</td><td>"GOFER_EXTENSION_GITHUB_REF<br/>"GOFER_EXTENSION_GITHUB_REF_TYPE"<br/>"GOFER_EXTENSION_GITHUB_REPOSITORY"</td></tr>
<tr><td>push</td><td>"GOFER_EXTENSION_GITHUB_REF"<br/>"GOFER_EXTENSION_GITHUB_REPOSITORY"<br/>"GOFER_EXTENSION_GITHUB_HEAD_COMMIT_ID"<br/>"GOFER_EXTENSION_GITHUB_HEAD_COMMIT_AUTHOR_NAME"<br/>"GOFER_EXTENSION_GITHUB_HEAD_COMMIT_AUTHOR_EMAIL"<br/>"GOFER_EXTENSION_GITHUB_HEAD_COMMIT_AUTHOR_USERNAME"<br/>"GOFER_EXTENSION_GITHUB_HEAD_COMMIT_COMMITER_NAME"<br/>"GOFER_EXTENSION_GITHUB_HEAD_COMMIT_COMMITER_EMAIL"<br/>"GOFER_EXTENSION_GITHUB_HEAD_COMMIT_COMMITER_USERNAME"</td></tr>
<tr><td>release</td><td>"GOFER_EXTENSION_GITHUB_ACTION"<br/>"GOFER_EXTENSION_GITHUB_REPOSITORY"<br/>"GOFER_EXTENSION_GITHUB_RELEASE_TAG_NAME"<br/>"GOFER_EXTENSION_GITHUB_RELEASE_TARGET_COMMITISH"<br/>"GOFER_EXTENSION_GITHUB_RELEASE_AUTHOR_LOGIN"<br/>"GOFER_EXTENSION_GITHUB_RELEASE_CREATED_AT"<br/>"GOFER_EXTENSION_GITHUB_RELEASE_PUBLISHED_AT"</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="command-line"><a class="header" href="#command-line">Command Line</a></h1>
<p>Gofer's main way of providing interaction is through a command line application included in the Gofer binary.</p>
<p>This command line tool is how you upload pipelines, view runs, upload artifacts and many other common Gofer tasks.</p>
<p>To view the possible commands for the Gofer pipeline simply run <code>gofer -h</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h1>
<p>The Gofer CLI accepts configuration through flags, environment variables, or a configuration file.</p>
<p>When multiple configuration sources are used the hierarchy is (from lowest to highest)
config file values -&gt; environment variables -&gt; flags. Meaning that if you give the same configurations different
values through a configuration file and through flags, the value given in the flag will prevail.</p>
<h2 id="flags"><a class="header" href="#flags">Flags</a></h2>
<p>You can view Gofer's global flags by simply typing <code>gofer -h</code>.</p>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment variables</a></h2>
<p>You can also set configuration values through environment variables. Each environment variable has a prefix
of <code>GOFER_</code>.</p>
<p>For example, setting your API token:</p>
<pre><code class="language-bash">export GOFER_TOKEN=mysupersecrettoken
gofer service token whoami
</code></pre>
<p>Each environment variable available is just the flag with a prefix of <code>GOFER_</code>.</p>
<pre><code class="language-bash">export GOFER_HOST=localhost:8080
</code></pre>
<h2 id="configuration-file-1"><a class="header" href="#configuration-file-1">Configuration file</a></h2>
<p>For convenience reasons Gofer can also use a standard configuration file. The language of this file is
<a href="https://toml.io/en/">TOML</a>. Most of the options are simply in the form of <code>key=value</code>.</p>
<h3 id="configuration-file-locations"><a class="header" href="#configuration-file-locations">Configuration file locations</a></h3>
<p>You can put your CLI configuration file in any of the following locations and Gofer will automatically
detect and read from it(in order of first searched):</p>
<ol>
<li>The path given to the <code>--config</code> flag</li>
<li>$HOME/.gofer.toml</li>
<li>$HOME/.config/gofer.toml</li>
</ol>
<h3 id="configuration-file-options"><a class="header" href="#configuration-file-options">Configuration file options</a></h3>
<p>The options available in the configuration file are the same as the global flags:</p>
<pre><code class="language-bash">gofer -h

...
Flags:
   --detail
...

# The flag 'detail' maps back to the configuration file as the same name

# gofer.toml
detail = false
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>configuration</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>namespace</td><td>string</td><td>The namespace ID of the namespace you'd like to default to. This is used to target specific namespaces when there might be multiple.</td></tr>
<tr><td>detail</td><td>string</td><td>Show extra detail for some commands (ex. Exact time instead of humanized)</td></tr>
<tr><td>output_format</td><td>string</td><td>Can be one of three values: <code>plain</code>, <code>silent</code>, <code>json</code>. Controls the output of CLI commands.</td></tr>
<tr><td>api_base_url</td><td>string</td><td>The URL of the Gofer server; used to point the CLI and that correct host.</td></tr>
<tr><td>token</td><td>string</td><td>The authentication token passed Gofer for Ident and Auth purposes.</td></tr>
<tr><td>debug</td><td>bool</td><td>Print debug statements.</td></tr>
</tbody></table>
</div>
<h3 id="example-configuration-file"><a class="header" href="#example-configuration-file">Example configuration file</a></h3>
<pre><code class="language-toml">// /home/clintjedwards/.gofer.toml
api_base_url = "http://127.0.0.1:8080/"
debug = false
detail = false
namespace = "default"
output_format = "plain"
token = "example"
token     = "mysupersecrettoken"
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
